name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  schedule:
    # æ¯å¤© UTC æ—¶é—´ 00:00 (å³åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # åœ¨ Secrets ä¸­é…ç½®é£ä¹¦æˆ–ä¼å¾®åœ°å€

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
      - name: éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
        run: |
          echo "=== è¿è¡Œå™¨ç¯å¢ƒæŠ¥å‘Š ==="
          echo "è¿è¡Œå™¨ç¯å¢ƒï¼š${{ runner.environment }}"
          echo "è¿è¡Œå™¨åç§°ï¼š${{ runner.name }}"
          echo "è¿è¡Œå™¨æ ‡ç­¾ï¼š${{ toJson(runner.labels) }}"
          
          # å†³å®šæ€§æ£€æŸ¥ï¼šå¦‚æœæ˜¯è‡ªæ‰˜ç®¡ç¯å¢ƒï¼Œç«‹å³å¤±è´¥
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "âŒ ä¸¥é‡é”™è¯¯ï¼šæ£€æµ‹åˆ°è‡ªæ‰˜ç®¡è¿è¡Œå™¨ (self-hosted)ã€‚"
            echo "è¿™æ„å‘³ç€æ‚¨çš„ 'ubuntu-latest' æ ‡ç­¾ä»è¢«æŸä¸ªè‡ªæ‰˜ç®¡è¿è¡Œå™¨åŒ¹é…ã€‚"
            echo "è¯·ç«‹å³æ£€æŸ¥å¹¶åˆ é™¤æ‚¨è´¦æˆ·ä¸‹æ ‡è®°ä¸º 'ubuntu-latest' çš„è‡ªæ‰˜ç®¡è¿è¡Œå™¨ã€‚"
            exit 1
          fi
          
          echo "âœ… å½“å‰è¿è¡Œäº GitHub æ‰˜ç®¡çš„è¿è¡Œå™¨ (${{ runner.os }})ã€‚"
          echo "å½“å‰å·¥ä½œç›®å½•ï¼š$(pwd)"
          echo "å¯ç”¨ç£ç›˜ç©ºé—´ï¼š"
          df -h
      
      # 2. æ£€å‡ºä»£ç 
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. å®‰è£…å¿…éœ€å·¥å…·
      - name: Install required tools
        run: |
          echo "=== å®‰è£…å¿…éœ€å·¥å…· ==="
          sudo apt-get update
          sudo apt-get install -y skopeo jq
          echo "âœ… skopeo ç‰ˆæœ¬: $(skopeo --version)"
          echo "âœ… jq ç‰ˆæœ¬: $(jq --version)"
      
      # 4. æœ€å¤§åŒ–æ„å»ºç©ºé—´
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. é‡å¯ Docker
      - name: Restart docker
        run: |
          echo "=== é‡å¯ Docker æœåŠ¡ ==="
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. åŒæ­¥é•œåƒåˆ°é˜¿é‡Œäº‘ (ä¿®å¤ç»“æœæ”¶é›†é—®é¢˜)
      - name: Sync and Push to Aliyun
        id: sync_step
        timeout-minutes: 45
        run: |
          echo "=== å¼€å§‹å¹¶è¡ŒåŒæ­¥é•œåƒåˆ°é˜¿é‡Œäº‘ ==="
          
          # ç™»å½•é˜¿é‡Œäº‘å®¹å™¨é•œåƒæœåŠ¡
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•å­˜æ”¾ç»“æœ
          mkdir -p /tmp/sync_results
          mkdir -p /tmp/sync_logs
          
          # ç¬¬ä¸€æ­¥ï¼šé¢„å¤„ç†ï¼Œæ‰¾å‡ºé‡åé•œåƒ
          echo "=== é¢„å¤„ç†ï¼šæ£€æµ‹é‡åé•œåƒ ==="
          declare -A duplicate_images
          declare -A temp_map
          
          while IFS= read -r line || [ -n "$line" ]; do
              # å¿½ç•¥ç©ºè¡Œä¸æ³¨é‡Š
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              
              # è·å–é•œåƒçš„å®Œæ•´åç§°
              raw_image=$(echo "$line" | awk '{print $NF}')
              # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
              image="${raw_image%%@*}"
              # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              # è·å–å‘½åç©ºé—´
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
              if [[ -z "$name_space" ]]; then
                  name_space="library"
              fi
              
              # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # å¦‚æœé•œåƒå­˜åœ¨äºæ•°ç»„ä¸­ï¼Œåˆ™æ£€æŸ¥æ˜¯å¦æœ‰é‡åå†²çª
              if [[ -n "${temp_map[$image_name]}" ]]; then
                   # å¦‚æœ temp_map å·²ç»å­˜åœ¨é•œåƒåï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åŒä¸€å‘½åç©ºé—´
                   if [[ "${temp_map[$image_name]}" != "$name_space" ]]; then
                      duplicate_images[$image_name]="true"
                   fi
              else
                  # å­˜é•œåƒçš„å‘½åç©ºé—´
                  temp_map[$image_name]="$name_space"
              fi
          done < images.txt
          
          echo "âœ… é¢„å¤„ç†å®Œæˆï¼Œå‘ç° ${#duplicate_images[@]} ä¸ªé‡åé•œåƒ"
          
          # å‡†å¤‡é•œåƒåˆ—è¡¨æ–‡ä»¶ï¼ˆè¿‡æ»¤æ³¨é‡Šå’Œç©ºè¡Œï¼‰
          grep -v '^\s*#' images.txt | grep -v '^\s*$' > /tmp/image_list.txt
          TOTAL_IMAGES=$(wc -l < /tmp/image_list.txt)
          echo "ğŸ“Š æ€»å…±éœ€è¦å¤„ç†çš„é•œåƒæ•°: $TOTAL_IMAGES"
          
          # ç¬¬äºŒæ­¥ï¼šå®šä¹‰å¤„ç†å•ä¸ªé•œåƒçš„å‡½æ•°
          echo "=== å¼€å§‹å¹¶è¡Œå¤„ç†é•œåƒ ==="
          echo "å¼€å§‹æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # å®šä¹‰å¤„ç†å•ä¸ªé•œåƒçš„å‡½æ•°
          process_single_image() {
              local line="$1"
              local line_number="$2"
              local job_id="$3"
              
              # åˆ›å»ºç‹¬ç«‹çš„æ—¥å¿—å’Œç»“æœæ–‡ä»¶
              local log_file="/tmp/sync_logs/job_${job_id}.log"
              local result_file="/tmp/sync_results/job_${job_id}.result"
              
              {
                  echo "=== å¤„ç†é•œåƒ [$line_number/$TOTAL_IMAGES] ==="
                  echo "åŸå§‹è¡Œ: $line"
                  
                  # è·å–åŸå§‹é•œåƒä¿¡æ¯
                  raw_image=$(echo "$line" | awk '{print $NF}')
                  # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
                  image="${raw_image%%@*}"
                  
                  # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
                  image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
                  # è·å–å‘½åç©ºé—´
                  name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
                  
                  # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
                  if [[ -z "$name_space" ]]; then
                      name_space="library"
                  fi
                  
                  # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
                  image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
                  
                  # æå–å¹³å°æ¶æ„ä¿¡æ¯
                  platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
                  
                  # å¦‚æœå­˜åœ¨æ¶æ„ä¿¡æ¯ï¼Œå°†æ¶æ„ä¿¡æ¯æ‹¼åˆ°é•œåƒåç§°å‰é¢
                  if [ -z "$platform" ]; then
                      platform_prefix=""
                  else
                      platform_prefix="${platform//\//_}_"
                  fi
                  
                  name_space_prefix=""
                  # å¦‚æœé•œåƒåé‡åä¸”å‘½åç©ºé—´ä¸åŒ
                  if [[ -n "${duplicate_images[$image_name]}" ]]; then
                     # å¦‚æœå‘½åç©ºé—´éç©ºï¼Œå°†å‘½åç©ºé—´åŠ åˆ°å‰ç¼€
                     name_space_prefix="${name_space}_"
                  fi
                  
                  # æ„é€ ç›®æ ‡é•œåƒåç§°
                  new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
                  
                  echo "åŸå§‹é•œåƒ: $image"
                  echo "ç›®æ ‡é•œåƒ: $new_image"
                  echo "å¹³å°æ¶æ„: ${platform:-é»˜è®¤}"
                  echo "å‘½åç©ºé—´: $name_space"
                  echo "é‡åå¤„ç†: ${duplicate_images[$image_name]:+æ˜¯ (ä½¿ç”¨å‰ç¼€)}"
                  
                  # ========== æ£€æŸ¥é•œåƒæ˜¯å¦éœ€è¦æ›´æ–° ==========
                  echo "æ£€æŸ¥é•œåƒçŠ¶æ€..."
                  
                  # 1. æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨
                  echo "æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨..."
                  if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                      # ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œé¦–å…ˆæ£€æŸ¥åˆ›å»ºæ—¶é—´
                      echo "ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œæ£€æŸ¥åˆ›å»ºæ—¶é—´..."
                      
                      # è·å–æºé•œåƒçš„åˆ›å»ºæ—¶é—´
                      SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                      # è·å–ç›®æ ‡é•œåƒçš„åˆ›å»ºæ—¶é—´
                      TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                          # è½¬æ¢ä¸ºæ—¶é—´æˆ³æ¯”è¾ƒ
                          SRC_TIMESTAMP=$(date -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                          TARGET_TIMESTAMP=$(date -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                          
                          # å¦‚æœç›®æ ‡é•œåƒåˆ›å»ºæ—¶é—´æ¯”æºé•œåƒæ™šæˆ–ç›¸åŒï¼ˆç›¸å·®åœ¨120ç§’å†…ï¼‰ï¼Œåˆ™è®¤ä¸ºæ˜¯æœ€æ–°
                          if [ "$TARGET_TIMESTAMP" -ge "$SRC_TIMESTAMP" ] || [ $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) -lt 120 ]; then
                              echo "âœ… åˆ›å»ºæ—¶é—´ç›¸è¿‘ï¼Œé•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡: $image_name_tag"
                              echo "  æºåˆ›å»ºæ—¶é—´: $SRC_CREATED ($SRC_TIMESTAMP)"
                              echo "  ç›®æ ‡åˆ›å»ºæ—¶é—´: $TARGET_CREATED ($TARGET_TIMESTAMP)"
                              echo "RESULT:SKIP:$image_name_tag:åˆ›å»ºæ—¶é—´ç›¸è¿‘" > "$result_file"
                              return 0
                          else
                              echo "ğŸ”„ ç›®æ ‡é•œåƒåˆ›å»ºæ—¶é—´è¾ƒæ—© (å·® $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) ç§’)ï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                          fi
                      else
                          echo "â„¹ï¸ æ— æ³•è·å–åˆ›å»ºæ—¶é—´ï¼Œæ£€æŸ¥é•œåƒå±‚..."
                          
                          # æ£€æŸ¥é•œåƒå±‚ä½œä¸ºåå¤‡æ–¹æ¡ˆ
                          SRC_LAYERS=$(skopeo inspect docker://$image --format '{{.Layers}}' 2>/dev/null || echo "")
                          TARGET_LAYERS=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Layers}}' 2>/dev/null || echo "")
                          
                          if [ -n "$SRC_LAYERS" ] && [ -n "$TARGET_LAYERS" ]; then
                              # å»é™¤æ–¹æ‹¬å·å¹¶æ’åºï¼Œç„¶åæ¯”è¾ƒ
                              SRC_CLEANED=$(echo "$SRC_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                              TARGET_CLEANED=$(echo "$TARGET_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                              
                              if [ "$SRC_CLEANED" = "$TARGET_CLEANED" ]; then
                                  echo "âœ… é•œåƒå±‚ç›¸åŒï¼Œé•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡: $image_name_tag"
                                  echo "RESULT:SKIP:$image_name_tag:é•œåƒå±‚ç›¸åŒ" > "$result_file"
                                  return 0
                              else
                                  echo "ğŸ”„ é•œåƒå±‚ä¸åŒï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                              fi
                          else
                              echo "ğŸ”„ æ— æ³•è·å–é•œåƒä¿¡æ¯ï¼Œå‡ºäºå®‰å…¨è€ƒè™‘æ‰§è¡ŒåŒæ­¥: $image_name_tag"
                          fi
                      fi
                  else
                      echo "ğŸ”„ ç›®æ ‡é•œåƒä¸å­˜åœ¨ï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                  fi
                  # ========== æ£€æŸ¥ç»“æŸ ==========
                  
                  echo "å¼€å§‹åŒæ­¥é•œåƒ..."
                  
                  # æ‰§è¡ŒåŒæ­¥ï¼ˆå¸¦è¶…æ—¶å’Œè¯¦ç»†æ—¥å¿—ï¼‰
                  # 1. æ‹‰å–é•œåƒ
                  echo "æ­¥éª¤ 1/3: æ‹‰å–æºé•œåƒ..."
                  PULL_SUCCESS=false
                  for attempt in {1..3}; do
                      echo "  å°è¯•æ‹‰å–ç¬¬ $attempt æ¬¡..."
                      if timeout 300 docker pull "$image"; then
                          echo "  âœ… æ‹‰å–æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          PULL_SUCCESS=true
                          break
                      else
                          echo "  âš ï¸ æ‹‰å–å¤±è´¥ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          if [ $attempt -lt 3 ]; then
                              sleep $((attempt * 5))
                          fi
                      fi
                  done
                  
                  if [ "$PULL_SUCCESS" = false ]; then
                      echo "  âŒ æ‹‰å–å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                      echo "RESULT:FAIL:$image_name_tag:æ‹‰å–å¤±è´¥" > "$result_file"
                      return 1
                  fi
                      
                  # 2. é‡æ–°æ ‡è®°é•œåƒ
                  echo "æ­¥éª¤ 2/3: é‡æ–°æ ‡è®°é•œåƒ..."
                  if docker tag "$image" "$new_image"; then
                      echo "  âœ… é‡æ ‡è®°æˆåŠŸ"
                      
                      # 3. æ¨é€åˆ°é˜¿é‡Œäº‘
                      echo "æ­¥éª¤ 3/3: æ¨é€åˆ°é˜¿é‡Œäº‘..."
                      PUSH_SUCCESS=false
                      for attempt in {1..3}; do
                          echo "  å°è¯•æ¨é€ç¬¬ $attempt æ¬¡..."
                          if timeout 600 docker push "$new_image"; then
                              echo "  âœ… æ¨é€æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                              PUSH_SUCCESS=true
                              break
                          else
                              echo "  âš ï¸ æ¨é€å¤±è´¥ (ç¬¬ $attempt æ¬¡å°è¯•)"
                              if [ $attempt -lt 3 ]; then
                                  sleep $((attempt * 5))
                              fi
                          fi
                      done
                      
                      if [ "$PUSH_SUCCESS" = false ]; then
                          echo "  âŒ æ¨é€å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                          echo "RESULT:FAIL:$image_name_tag:æ¨é€å¤±è´¥" > "$result_file"
                          return 1
                      else
                          # æ¸…ç†æœ¬åœ°é•œåƒ
                          docker rmi "$image" "$new_image" 2>/dev/null || true
                          docker system prune -f 2>/dev/null || true
                          
                          echo "RESULT:SUCCESS:$image_name_tag" > "$result_file"
                          return 0
                      fi
                  else
                      echo "  âŒ é‡æ ‡è®°å¤±è´¥"
                      echo "RESULT:FAIL:$image_name_tag:é‡å‘½åå¤±è´¥" > "$result_file"
                      return 1
                  fi
              } > "$log_file" 2>&1
              
              # ç¡®ä¿ç»“æœæ–‡ä»¶å­˜åœ¨
              if [ ! -f "$result_file" ]; then
                  echo "RESULT:FAIL:$image_name_tag:æœªè¿”å›ç»“æœ" > "$result_file"
              fi
          }
          
          # å¯¼å‡ºå‡½æ•°ä»¥ä¾¿ä½¿ç”¨
          export -f process_single_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          export TOTAL_IMAGES
          
          # å°†é‡åé•œåƒä¿¡æ¯å¯¼å‡ºä¸ºç¯å¢ƒå˜é‡
          for key in "${!duplicate_images[@]}"; do
              export "duplicate_images_$key=1"
          done
          
          # ä½¿ç”¨ç®€å•çš„å¹¶è¡Œå¤„ç†ï¼šåå°ä½œä¸š
          MAX_JOBS=3
          job_counter=0
          
          # æ¸…ç©ºç»“æœç›®å½•
          rm -f /tmp/sync_results/*.result
          
          while IFS= read -r line; do
              job_counter=$((job_counter + 1))
              
              # å¯åŠ¨åå°ä½œä¸šå¤„ç†é•œåƒ
              (
                  echo "ğŸš€ å¯åŠ¨ä½œä¸š $job_counter å¤„ç†ç¬¬ $job_counter ä¸ªé•œåƒ"
                  process_single_image "$line" "$job_counter" "$job_counter"
                  echo "ğŸ ä½œä¸š $job_counter å®Œæˆ"
              ) &
              
              # æ§åˆ¶å¹¶å‘æ•°
              running_jobs=$(jobs -r -p | wc -l)
              while [ $running_jobs -ge $MAX_JOBS ]; do
                  sleep 1
                  running_jobs=$(jobs -r -p | wc -l)
              done
              
          done < /tmp/image_list.txt
          
          # ç­‰å¾…æ‰€æœ‰åå°ä½œä¸šå®Œæˆ
          echo "â³ ç­‰å¾…æ‰€æœ‰ä½œä¸šå®Œæˆ..."
          wait
          
          echo "ç»“æŸæ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "=== å¹¶è¡Œå¤„ç†å®Œæˆ ==="
          
          # ç¬¬ä¸‰æ­¥ï¼šæ±‡æ€»ç»“æœ
          echo "=== æ±‡æ€»å¤„ç†ç»“æœ ==="
          
          # æ”¶é›†æ‰€æœ‰ç»“æœ
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          SKIP_COUNT=0
          SYNC_SUMMARY=""
          
          # ä½¿ç”¨ find å‘½ä»¤å®‰å…¨åœ°è·å–ç»“æœæ–‡ä»¶åˆ—è¡¨ï¼Œå³ä½¿ä¸ºç©º
          result_files=$(find /tmp/sync_results -name "*.result" 2>/dev/null)
          echo "ğŸ“ æ‰¾åˆ°ç»“æœæ–‡ä»¶æ•°é‡: $(echo "$result_files" | wc -l)"
          
          # è¯»å–æ‰€æœ‰ç»“æœæ–‡ä»¶
          if [ -n "$result_files" ]; then
              while IFS= read -r result_file; do
                  if [ -f "$result_file" ]; then
                      result_line=$(cat "$result_file" 2>/dev/null || echo "")
                      if [ -n "$result_line" ]; then
                          if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                              img_name=$(echo "$result_line" | cut -d: -f3-)
                              SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ $img_name"
                              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                          elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                              img_name=$(echo "$result_line" | cut -d: -f3-)
                              SYNC_SUMMARY="${SYNC_SUMMARY}\nâ­ï¸ $img_name"
                              SKIP_COUNT=$((SKIP_COUNT + 1))
                          elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                              img_name=$(echo "$result_line" | cut -d: -f3-)
                              SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $img_name"
                              FAILURE_COUNT=$((FAILURE_COUNT + 1))
                          fi
                      fi
                  fi
              done <<< "$result_files"
          fi
          
          echo "ğŸ“Š ç»Ÿè®¡ç»“æœ:"
          echo "  æˆåŠŸ: $SUCCESS_COUNT"
          echo "  è·³è¿‡: $SKIP_COUNT"
          echo "  å¤±è´¥: $FAILURE_COUNT"
          
          # å¦‚æœæ²¡æœ‰ç»“æœï¼Œå°è¯•ä»æ—¥å¿—ä¸­æå–
          if [ $SUCCESS_COUNT -eq 0 ] && [ $SKIP_COUNT -eq 0 ] && [ $FAILURE_COUNT -eq 0 ]; then
              echo "âš ï¸ ç»“æœæ–‡ä»¶ä¸ºç©ºï¼Œå°è¯•ä»æ—¥å¿—ä¸­æå–ç»“æœ..."
              
              log_files=$(find /tmp/sync_logs -name "*.log" 2>/dev/null)
              if [ -n "$log_files" ]; then
                  while IFS= read -r log_file; do
                      if [ -f "$log_file" ]; then
                          if grep -q "^RESULT:" "$log_file"; then
                              result_line=$(grep "^RESULT:" "$log_file" | tail -1)
                              if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                                  img_name=$(echo "$result_line" | cut -d: -f3-)
                                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ $img_name"
                                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                              elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                                  img_name=$(echo "$result_line" | cut -d: -f3-)
                                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâ­ï¸ $img_name"
                                  SKIP_COUNT=$((SKIP_COUNT + 1))
                              elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                                  img_name=$(echo "$result_line" | cut -d: -f3-)
                                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $img_name"
                                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                              fi
                          fi
                      fi
                  done <<< "$log_files"
              fi
          fi
          
          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "æœ¬æ¬¡æ²¡æœ‰éœ€è¦åŒæ­¥çš„æ–°é•œåƒ"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # æ˜¾ç¤ºå¤„ç†å®Œæˆçš„ä½œä¸šæ•°
          echo "âœ… å·²å¤„ç†ä½œä¸šæ•°: $job_counter"
          echo "ğŸ“ ç»“æœæ–‡ä»¶æ€»æ•°: $(find /tmp/sync_results -name "*.result" 2>/dev/null | wc -l)"
          
          # å¦‚æœæœ‰å¤±è´¥ï¼Œè¿”å›éé›¶é€€å‡ºç 
          if [ "$FAILURE_COUNT" -gt 0 ]; then
              echo "âš ï¸ æœ‰ $FAILURE_COUNT ä¸ªé•œåƒåŒæ­¥å¤±è´¥"
              exit 1
          fi
      
      # 7. æ¸…ç† Docker ç³»ç»Ÿ
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== æ¸…ç† Docker ç³»ç»Ÿ ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          echo "âœ… æ¸…ç†å®Œæˆ"
          echo "å‰©ä½™ç£ç›˜ç©ºé—´:"
          df -h
      
      # 8. å‘é€ Webhook é€šçŸ¥
      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "âš ï¸ æœªé…ç½® Webhook URLï¼Œè·³è¿‡é€šçŸ¥"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          K_COUNT=${{ env.SKIP_COUNT }}
          
          # 1. åˆ¤å®šæ ‡é¢˜å’Œä¸»çŠ¶æ€
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="âŒ é˜¿é‡Œäº‘é•œåƒåŒæ­¥å¤±è´¥"
              CONTENT="âš ï¸ è­¦å‘Šï¼šæœ‰ $F_COUNT ä¸ªé•œåƒåŒæ­¥å‡ºç°å¼‚å¸¸ï¼Œè¯·åŠæ—¶æ£€æŸ¥ã€‚"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="âœ… é˜¿é‡Œäº‘é•œåƒåŒæ­¥æˆåŠŸ"
              CONTENT="æœ¬æ¬¡æ–°å¢åŒæ­¥é•œåƒå¦‚ä¸‹ï¼š"
          elif [ "$K_COUNT" -gt 0 ]; then
              TITLE="â­ï¸ åŒæ­¥ä»»åŠ¡å®Œæˆ (é•œåƒå·²æ˜¯æœ€æ–°)"
              CONTENT="æ‰€æœ‰é•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œæ— éœ€åŒæ­¥ã€‚"
          else
              TITLE="â˜• åŒæ­¥ä»»åŠ¡å®Œæˆ (æ— é•œåƒéœ€è¦å¤„ç†)"
              CONTENT="æ£€æµ‹åˆ° images.txt ä¸­æ— æœ‰æ•ˆé•œåƒéœ€è¦å¤„ç†ã€‚"
          fi
          
          # 2. ç»„è£…æœ€ç»ˆæ–‡æœ¬
          RAW_TEXT=$(cat <<EOF
          $TITLE
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          ğŸ“Š ç»Ÿè®¡: æˆåŠŸ $S_COUNT | è·³è¿‡ $K_COUNT | å¤±è´¥ $F_COUNT
          ğŸ“… æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')
          ğŸ”— è¯¦æƒ…: [æŸ¥çœ‹ GitHub Action æ—¥å¿—](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          # 3. å‘é€é€šçŸ¥
          echo "å‘é€ Webhook é€šçŸ¥..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          # å°è¯•å‘é€ï¼Œæœ€å¤šé‡è¯•3æ¬¡
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "âœ… é€šçŸ¥å‘é€æˆåŠŸ (å°è¯• $i æ¬¡)"
                  break
              else
                  echo "âš ï¸ é€šçŸ¥å‘é€å¤±è´¥ï¼Œç¬¬ $i æ¬¡å°è¯•"
                  sleep 2
              fi
          done
