name: Docker Image Sync to Aliyun (Parallel - Fixed)

on:
  workflow_dispatch:
  schedule:
    # æ¯å¤© UTC æ—¶é—´ 00:00 (å³åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}"

jobs:
  build:
    name: Sync Images (Parallel)
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
      - name: éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
        run: |
          echo "=== è¿è¡Œå™¨ç¯å¢ƒæŠ¥å‘Š ==="
          echo "è¿è¡Œå™¨ç¯å¢ƒï¼š${{ runner.environment }}"
          echo "è¿è¡Œå™¨åç§°ï¼š${{ runner.name }}"
          echo "è¿è¡Œå™¨æ ‡ç­¾ï¼š${{ toJson(runner.labels) }}"
          
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "âŒ ä¸¥é‡é”™è¯¯ï¼šæ£€æµ‹åˆ°è‡ªæ‰˜ç®¡è¿è¡Œå™¨ (self-hosted)ã€‚"
            echo "è¯·ç«‹å³æ£€æŸ¥å¹¶åˆ é™¤æ‚¨è´¦æˆ·ä¸‹æ ‡è®°ä¸º 'ubuntu-latest' çš„è‡ªæ‰˜ç®¡è¿è¡Œå™¨ã€‚"
            exit 1
          fi
          
          echo "âœ… å½“å‰è¿è¡Œäº GitHub æ‰˜ç®¡çš„è¿è¡Œå™¨ (${{ runner.os }})ã€‚"
          echo "å½“å‰å·¥ä½œç›®å½•ï¼š$(pwd)"
          echo "å¯ç”¨ç£ç›˜ç©ºé—´ï¼š"
          df -h
      
      # 2. æ£€å‡ºä»£ç 
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. å®‰è£…å¿…éœ€å·¥å…·
      - name: Install required tools
        run: |
          echo "=== å®‰è£…å¿…éœ€å·¥å…· ==="
          sudo apt-get update
          sudo apt-get install -y skopeo jq parallel
          echo "âœ… skopeo ç‰ˆæœ¬: $(skopeo --version)"
          echo "âœ… jq ç‰ˆæœ¬: $(jq --version)"
          echo "âœ… parallel ç‰ˆæœ¬: $(parallel --version | head -1)"
      
      # 4. æœ€å¤§åŒ–æ„å»ºç©ºé—´
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. é‡å¯ Docker
      - name: Restart docker
        run: |
          echo "=== é‡å¯ Docker æœåŠ¡ ==="
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. ç™»å½•é˜¿é‡Œäº‘
      - name: Login to Aliyun Registry
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          echo "âœ… ç™»å½•é˜¿é‡Œäº‘é•œåƒä»“åº“æˆåŠŸ"
      
      # 7. ä½¿ç”¨ç®€åŒ–ä½†å¯é çš„å¹¶è¡Œå¤„ç† (ä¿®å¤ç‰ˆ)
      - name: Parallel Sync and Push to Aliyun
        id: sync_step
        timeout-minutes: 45
        run: |
          echo "=== å¼€å§‹åŒæ­¥é•œåƒåˆ°é˜¿é‡Œäº‘ ==="
          
          # åˆ›å»ºæ—¥å¿—å’Œç»“æœç›®å½•
          mkdir -p /tmp/sync_results /tmp/sync_logs
          
          # ç¬¬ä¸€æ­¥ï¼šå¤„ç†é•œåƒåˆ—è¡¨æ–‡ä»¶
          echo "=== å‡†å¤‡é•œåƒåˆ—è¡¨ ==="
          
          # ç”Ÿæˆè¦å¤„ç†çš„é•œåƒåˆ—è¡¨ï¼ˆæ’é™¤æ³¨é‡Šå’Œç©ºè¡Œï¼‰
          : > /tmp/image_list.txt
          line_num=0
          while IFS= read -r line || [ -n "$line" ]; do
              line_num=$((line_num + 1))
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              echo "$line_num \"$line\"" >> /tmp/image_list.txt
          done < images.txt
          
          TOTAL_IMAGES=$(wc -l < /tmp/image_list.txt)
          echo "ğŸ“Š æ€»å…±éœ€è¦å¤„ç†çš„é•œåƒæ•°: $TOTAL_IMAGES"
          
          # ç¬¬äºŒæ­¥ï¼šç®€åŒ–å¤„ç† - ä½¿ç”¨ xargs è¿›è¡Œå¹¶è¡Œå¤„ç†
          echo "=== ä½¿ç”¨ xargs å¹¶è¡Œå¤„ç† ==="
          echo "å¼€å§‹æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # å®šä¹‰å¤„ç†å•ä¸ªé•œåƒçš„å‡½æ•°
          process_single_image() {
              local line_num="$1"
              local line="$2"
              local job_id="$3"
              
              local log_file="/tmp/sync_logs/job_${job_id}.log"
              local result_file="/tmp/sync_results/job_${job_id}.result"
              
              {
                  echo "=== å¤„ç†é•œåƒ [$line_num/$TOTAL_IMAGES] ==="
                  echo "åŸå§‹è¡Œ: $line"
                  
                  # è·å–åŸå§‹é•œåƒä¿¡æ¯
                  raw_image=$(echo "$line" | awk '{print $NF}')
                  image="${raw_image%%@*}"
                  image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
                  
                  # æå–å¹³å°æ¶æ„ä¿¡æ¯
                  platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
                  [[ -n "$platform" ]] && platform_prefix="${platform//\//_}_" || platform_prefix=""
                  
                  # è·å–å‘½åç©ºé—´
                  name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
                  [[ -z "$name_space" ]] && name_space="library"
                  
                  # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰
                  image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
                  
                  # æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒé•œåƒåä½†ä¸åŒå‘½åç©ºé—´çš„æƒ…å†µ
                  name_space_prefix=""
                  if [[ "$name_space" != "library" ]]; then
                      # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–é•œåƒæœ‰ç›¸åŒçš„é•œåƒå
                      while IFS= read -r check_line; do
                          [[ -z "$check_line" ]] && continue
                          if echo "$check_line" | grep -q '^\s*#'; then
                              continue
                          fi
                          
                          check_raw=$(echo "$check_line" | awk '{print $NF}')
                          check_image="${check_raw%%@*}"
                          check_name_tag=$(echo "$check_image" | awk -F'/' '{print $NF}')
                          check_image_name=$(echo "$check_name_tag" | awk -F':' '{print $1}')
                          
                          if [[ "$check_image_name" == "$image_name" ]]; then
                              check_namespace=$(echo "$check_image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
                              [[ -z "$check_namespace" ]] && check_namespace="library"
                              
                              if [[ "$check_namespace" != "$name_space" ]]; then
                                  name_space_prefix="${name_space}_"
                                  echo "âš ï¸ å‘ç°é‡åé•œåƒ '$image_name'ï¼Œæ·»åŠ å‘½åç©ºé—´å‰ç¼€: $name_space_prefix"
                                  break
                              fi
                          fi
                      done < <(grep -v '^\s*#' images.txt | grep -v '^\s*$')
                  fi
                  
                  # æ„é€ ç›®æ ‡é•œåƒåç§°
                  new_image="${ALIYUN_REGISTRY}/${ALIYUN_NAME_SPACE}/${platform_prefix}${name_space_prefix}${image_name_tag}"
                  
                  echo "åŸå§‹é•œåƒ: $image"
                  echo "ç›®æ ‡é•œåƒ: $new_image"
                  echo "å¹³å°æ¶æ„: ${platform:-é»˜è®¤}"
                  echo "å‘½åç©ºé—´: $name_space"
                  
                  # æ£€æŸ¥é•œåƒæ˜¯å¦éœ€è¦åŒæ­¥
                  echo "æ£€æŸ¥é•œåƒçŠ¶æ€..."
                  
                  # æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨
                  if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                      # ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œæ£€æŸ¥åˆ›å»ºæ—¶é—´
                      SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                      TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                          SRC_TIMESTAMP=$(date -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                          TARGET_TIMESTAMP=$(date -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                          
                          if [ "$TARGET_TIMESTAMP" -ge "$SRC_TIMESTAMP" ] || [ $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) -lt 120 ]; then
                              echo "âœ… é•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡: $image_name_tag"
                              echo "RESULT:SKIP:$image_name_tag:å·²æ˜¯æœ€æ–°" > "$result_file"
                              return 0
                          fi
                      fi
                      
                      # æ£€æŸ¥é•œåƒå±‚
                      SRC_LAYERS=$(skopeo inspect docker://$image --format '{{.Layers}}' 2>/dev/null || echo "")
                      TARGET_LAYERS=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Layers}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_LAYERS" ] && [ -n "$TARGET_LAYERS" ]; then
                          SRC_CLEANED=$(echo "$SRC_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                          TARGET_CLEANED=$(echo "$TARGET_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                          
                          if [ "$SRC_CLEANED" = "$TARGET_CLEANED" ]; then
                              echo "âœ… é•œåƒå±‚ç›¸åŒï¼Œè·³è¿‡: $image_name_tag"
                              echo "RESULT:SKIP:$image_name_tag:é•œåƒå±‚ç›¸åŒ" > "$result_file"
                              return 0
                          fi
                      fi
                  fi
                  
                  # éœ€è¦åŒæ­¥é•œåƒ
                  echo "ğŸ”„ éœ€è¦åŒæ­¥é•œåƒ: $image_name_tag"
                  
                  # æ‹‰å–é•œåƒ
                  echo "æ­¥éª¤ 1/3: æ‹‰å–æºé•œåƒ..."
                  for attempt in {1..3}; do
                      if timeout 300 docker pull "$image" > /dev/null 2>&1; then
                          echo "âœ… æ‹‰å–æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          break
                      elif [ $attempt -eq 3 ]; then
                          echo "âŒ æ‹‰å–å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                          echo "RESULT:FAIL:$image_name_tag:æ‹‰å–å¤±è´¥" > "$result_file"
                          return 1
                      else
                          echo "âš ï¸ æ‹‰å–å¤±è´¥ï¼Œç­‰å¾…é‡è¯•..."
                          sleep $((attempt * 5))
                      fi
                  done
                  
                  # æ ‡è®°é•œåƒ
                  echo "æ­¥éª¤ 2/3: é‡æ–°æ ‡è®°é•œåƒ..."
                  if docker tag "$image" "$new_image"; then
                      echo "âœ… é‡æ ‡è®°æˆåŠŸ"
                  else
                      echo "âŒ é‡æ ‡è®°å¤±è´¥"
                      echo "RESULT:FAIL:$image_name_tag:é‡å‘½åå¤±è´¥" > "$result_file"
                      return 1
                  fi
                  
                  # æ¨é€é•œåƒ
                  echo "æ­¥éª¤ 3/3: æ¨é€åˆ°é˜¿é‡Œäº‘..."
                  for attempt in {1..3}; do
                      if timeout 600 docker push "$new_image" > /dev/null 2>&1; then
                          echo "âœ… æ¨é€æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          
                          # æ¸…ç†æœ¬åœ°é•œåƒ
                          docker rmi "$image" "$new_image" 2>/dev/null || true
                          
                          echo "RESULT:SUCCESS:$image_name_tag" > "$result_file"
                          return 0
                      elif [ $attempt -eq 3 ]; then
                          echo "âŒ æ¨é€å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                          echo "RESULT:FAIL:$image_name_tag:æ¨é€å¤±è´¥" > "$result_file"
                          return 1
                      else
                          echo "âš ï¸ æ¨é€å¤±è´¥ï¼Œç­‰å¾…é‡è¯•..."
                          sleep $((attempt * 5))
                      fi
                  done
                  
              } > "$log_file" 2>&1
              
              # ç¡®ä¿ç»“æœæ–‡ä»¶å­˜åœ¨
              if [ ! -f "$result_file" ]; then
                  echo "RESULT:FAIL:$image_name_tag:æœªè¿”å›ç»“æœ" > "$result_file"
              fi
          }
          
          # å¯¼å‡ºå‡½æ•°
          export -f process_single_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          export TOTAL_IMAGES
          
          # ä½¿ç”¨ xargs è¿›è¡Œå¹¶è¡Œå¤„ç† (æ›´ç¨³å®š)
          echo "å¼€å§‹å¹¶è¡Œå¤„ç†..."
          
          # æ¸…ç©ºç»“æœç›®å½•
          rm -f /tmp/sync_results/*.result /tmp/sync_logs/*.log
          
          # ä¸ºæ¯ä¸ªé•œåƒåˆ†é…ä¸€ä¸ªä½œä¸šID
          job_id=0
          while IFS= read -r line; do
              job_id=$((job_id + 1))
              echo "$job_id $line" >> /tmp/jobs.txt
          done < /tmp/image_list.txt
          
          # ä½¿ç”¨ xargs å¹¶è¡Œå¤„ç†ï¼Œæœ€å¤§å¹¶å‘æ•°è®¾ä¸º 2 ä»¥é¿å…èµ„æºç«äº‰
          cat /tmp/jobs.txt | while read -r job_id line; do
              # ä½¿ç”¨å­shellæ‰§è¡Œï¼Œé¿å…ä½œä¸šé—´å¹²æ‰°
              (
                  # è§£æè¡Œå·å’Œé•œåƒè¡Œ
                  line_num=$(echo "$line" | awk '{print $1}')
                  img_line=$(echo "$line" | sed 's/^[0-9]* //' | sed 's/^"//;s/"$//')
                  
                  # è°ƒç”¨å¤„ç†å‡½æ•°
                  process_single_image "$line_num" "$img_line" "$job_id"
                  
                  # ç®€å•æ¸…ç†
                  docker system prune -f 2>/dev/null || true
              ) &
              
              # æ§åˆ¶å¹¶å‘æ•°
              if [[ $(jobs -r -p | wc -l) -ge 2 ]]; then
                  wait -n
              fi
          done
          
          # ç­‰å¾…æ‰€æœ‰åå°ä½œä¸šå®Œæˆ
          echo "â³ ç­‰å¾…æ‰€æœ‰ä½œä¸šå®Œæˆ..."
          wait
          
          echo "ç»“æŸæ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "=== å¹¶è¡Œå¤„ç†å®Œæˆ ==="
          
          # ç¬¬ä¸‰æ­¥ï¼šæ±‡æ€»ç»“æœ
          echo "=== æ±‡æ€»å¤„ç†ç»“æœ ==="
          
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          SKIP_COUNT=0
          SYNC_SUMMARY=""
          
          # è¯»å–æ‰€æœ‰ç»“æœæ–‡ä»¶
          for result_file in /tmp/sync_results/*.result; do
              [ -f "$result_file" ] || continue
              result_line=$(cat "$result_file" 2>/dev/null | head -1)
              if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ $img_name"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâ­ï¸ $img_name"
                  SKIP_COUNT=$((SKIP_COUNT + 1))
              elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $img_name"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
              fi
          done
          
          echo "ğŸ“Š ç»Ÿè®¡ç»“æœ:"
          echo "  æˆåŠŸ: $SUCCESS_COUNT"
          echo "  è·³è¿‡: $SKIP_COUNT"
          echo "  å¤±è´¥: $FAILURE_COUNT"
          
          # å¦‚æœæœ‰å¤±è´¥ï¼Œæ˜¾ç¤ºå¤±è´¥ä½œä¸šçš„æ—¥å¿—
          if [ "$FAILURE_COUNT" -gt 0 ]; then
              echo "=== å¤±è´¥ä½œä¸šæ—¥å¿— ==="
              for result_file in /tmp/sync_results/*.result; do
                  [ -f "$result_file" ] || continue
                  if grep -q "RESULT:FAIL:" "$result_file"; then
                      job_id=$(basename "$result_file" .result | cut -d_ -f2)
                      echo "--- ä½œä¸š $job_id å¤±è´¥ ---"
                      cat "/tmp/sync_logs/job_${job_id}.log" 2>/dev/null | tail -20 || echo "æ— æ—¥å¿—"
                      echo ""
                  fi
              done
          fi
          
          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "æœ¬æ¬¡æ²¡æœ‰éœ€è¦åŒæ­¥çš„æ–°é•œåƒ"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # å¦‚æœæœ‰å¤±è´¥ï¼Œè¿”å›éé›¶é€€å‡ºç 
          if [ "$FAILURE_COUNT" -gt 0 ]; then
              echo "âŒ æœ‰ $FAILURE_COUNT ä¸ªé•œåƒåŒæ­¥å¤±è´¥"
              exit 1
          else
              echo "âœ… æ‰€æœ‰é•œåƒå¤„ç†å®Œæˆ"
          fi
      
      # 8. æ¸…ç† Docker ç³»ç»Ÿ
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== æ¸…ç† Docker ç³»ç»Ÿ ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          echo "âœ… æ¸…ç†å®Œæˆ"
          echo "å‰©ä½™ç£ç›˜ç©ºé—´:"
          df -h
      
      # 9. å‘é€ Webhook é€šçŸ¥
      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "âš ï¸ æœªé…ç½® Webhook URLï¼Œè·³è¿‡é€šçŸ¥"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          K_COUNT=${{ env.SKIP_COUNT }}
          
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="âŒ é˜¿é‡Œäº‘é•œåƒåŒæ­¥å¤±è´¥ (å¹¶è¡Œç‰ˆ)"
              CONTENT="âš ï¸ è­¦å‘Šï¼šæœ‰ $F_COUNT ä¸ªé•œåƒåŒæ­¥å‡ºç°å¼‚å¸¸ï¼Œè¯·åŠæ—¶æ£€æŸ¥ã€‚"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="âœ… é˜¿é‡Œäº‘é•œåƒåŒæ­¥æˆåŠŸ (å¹¶è¡Œç‰ˆ)"
              CONTENT="æœ¬æ¬¡æ–°å¢åŒæ­¥é•œåƒå¦‚ä¸‹ï¼š"
          elif [ "$K_COUNT" -gt 0 ]; then
              TITLE="â­ï¸ åŒæ­¥ä»»åŠ¡å®Œæˆ (å¹¶è¡Œç‰ˆ - é•œåƒå·²æ˜¯æœ€æ–°)"
              CONTENT="æ‰€æœ‰é•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œæ— éœ€åŒæ­¥ã€‚"
          else
              TITLE="â˜• åŒæ­¥ä»»åŠ¡å®Œæˆ (å¹¶è¡Œç‰ˆ - æ— é•œåƒéœ€è¦å¤„ç†)"
              CONTENT="æ£€æµ‹åˆ° images.txt ä¸­æ— æœ‰æ•ˆé•œåƒéœ€è¦å¤„ç†ã€‚"
          fi
          
          RAW_TEXT=$(cat <<EOF
          $TITLE
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          ğŸ“Š ç»Ÿè®¡: æˆåŠŸ $S_COUNT | è·³è¿‡ $K_COUNT | å¤±è´¥ $F_COUNT
          ğŸ“… æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')
          ğŸ”— è¯¦æƒ…: [æŸ¥çœ‹ GitHub Action æ—¥å¿—](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          echo "å‘é€ Webhook é€šçŸ¥..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "âœ… é€šçŸ¥å‘é€æˆåŠŸ (å°è¯• $i æ¬¡)"
                  break
              else
                  echo "âš ï¸ é€šçŸ¥å‘é€å¤±è´¥ï¼Œç¬¬ $i æ¬¡å°è¯•"
                  sleep 2
              fi
          done
