name: Docker Image Sync to Aliyun (Parallel - Fixed)

on:
  workflow_dispatch:
  schedule:
    # 每天 UTC 时间 00:00 (即北京时间 08:00) 运行
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}"

jobs:
  build:
    name: Sync Images (Parallel)
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. 验证运行器环境
      - name: 验证运行器环境
        run: |
          echo "=== 运行器环境报告 ==="
          echo "运行器环境：${{ runner.environment }}"
          echo "运行器名称：${{ runner.name }}"
          echo "运行器标签：${{ toJson(runner.labels) }}"
          
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "❌ 严重错误：检测到自托管运行器 (self-hosted)。"
            echo "请立即检查并删除您账户下标记为 'ubuntu-latest' 的自托管运行器。"
            exit 1
          fi
          
          echo "✅ 当前运行于 GitHub 托管的运行器 (${{ runner.os }})。"
          echo "当前工作目录：$(pwd)"
          echo "可用磁盘空间："
          df -h
      
      # 2. 检出代码
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. 安装必需工具
      - name: Install required tools
        run: |
          echo "=== 安装必需工具 ==="
          sudo apt-get update
          sudo apt-get install -y skopeo jq parallel  # 添加 parallel 工具
          echo "✅ skopeo 版本: $(skopeo --version)"
          echo "✅ jq 版本: $(jq --version)"
          echo "✅ parallel 版本: $(parallel --version | head -1)"
      
      # 4. 最大化构建空间
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. 重启 Docker
      - name: Restart docker
        run: |
          echo "=== 重启 Docker 服务 ==="
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. 登录阿里云
      - name: Login to Aliyun Registry
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          echo "✅ 登录阿里云镜像仓库成功"
      
      # 7. 准备并执行并行同步 (核心修复步骤)
      - name: Parallel Sync and Push to Aliyun
        id: sync_step
        timeout-minutes: 45
        run: |
          echo "=== 开始并行同步镜像到阿里云 (修复版) ==="
          
          # 创建日志和结果目录
          mkdir -p /tmp/sync_results /tmp/sync_logs
          
          # 第一步：预处理，找出重名镜像，并将结果写入文件
          echo "=== 预处理：检测重名镜像并生成配置 ==="
          
          # 生成一个文件，每行包含：行号 原始镜像 命名空间 是否重名
          : > /tmp/image_config.txt
          declare -A name_space_map
          declare -A duplicate_check
          
          line_num=0
          while IFS= read -r line || [ -n "$line" ]; do
              line_num=$((line_num + 1))
              
              # 忽略空行与注释
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              
              # 获取镜像信息
              raw_image=$(echo "$line" | awk '{print $NF}')
              image="${raw_image%%@*}"
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              [[ -z "$name_space" ]] && name_space="library"
              
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # 检测重名冲突
              duplicate="false"
              if [[ -n "${name_space_map[$image_name]}" ]]; then
                  if [[ "${name_space_map[$image_name]}" != "$name_space" ]]; then
                      duplicate="true"
                      duplicate_check[$image_name]="true"
                  fi
              else
                  name_space_map[$image_name]="$name_space"
              fi
              
              # 如果是已知的重名镜像，但当前命名空间与记录不同，也标记为重名
              if [[ -n "${duplicate_check[$image_name]}" ]]; then
                  duplicate="true"
              fi
              
              # 写入配置文件
              echo "$line_num \"$line\" \"$name_space\" \"$duplicate\"" >> /tmp/image_config.txt
          done < images.txt
          
          # 将重名镜像列表写入文件，供处理函数读取
          for key in "${!duplicate_check[@]}"; do
              echo "$key" >> /tmp/duplicate_images.txt
          done
          
          echo "✅ 预处理完成，发现 ${#duplicate_check[@]} 个重名镜像"
          echo "📊 有效镜像行数: $(wc -l < /tmp/image_config.txt)"
          
          # 第二步：定义真正有效的处理函数
          process_image() {
              local config_line="$1"
              local job_id="$2"
              
              # 解析配置行
              read -r line_num raw_line name_space duplicate <<< $(echo "$config_line" | sed 's/^"//;s/" "/ /g;s/"$//')
              
              local log_file="/tmp/sync_logs/job_${job_id}.log"
              local result_file="/tmp/sync_results/job_${job_id}.result"
              
              {
                  echo "=== 处理作业 $job_id (第 $line_num 行) ==="
                  echo "原始行: $raw_line"
                  
                  # 从原始行获取镜像信息
                  raw_image=$(echo "$raw_line" | awk '{print $NF}')
                  image="${raw_image%%@*}"
                  image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
                  image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
                  
                  # 提取平台架构
                  platform=$(echo "$raw_line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
                  [[ -n "$platform" ]] && platform_prefix="${platform//\//_}_" || platform_prefix=""
                  
                  # 确定是否添加命名空间前缀
                  name_space_prefix=""
                  if [[ "$duplicate" == "true" ]]; then
                      # 检查是否在重名列表文件中
                      if grep -q "^${image_name}$" /tmp/duplicate_images.txt 2>/dev/null; then
                          name_space_prefix="${name_space}_"
                      fi
                  fi
                  
                  # 构造目标镜像名称 (使用实际变量而非环境变量)
                  ALIYUN_REGISTRY="$ALIYUN_REGISTRY"
                  ALIYUN_NAME_SPACE="$ALIYUN_NAME_SPACE"
                  new_image="${ALIYUN_REGISTRY}/${ALIYUN_NAME_SPACE}/${platform_prefix}${name_space_prefix}${image_name_tag}"
                  
                  echo "原始镜像: $image"
                  echo "目标镜像: $new_image"
                  echo "命名空间: $name_space (重复: $duplicate)"
                  echo "平台架构: ${platform:-默认}"
                  
                  # 核心检查步骤 (与稳定版逻辑一致)
                  echo "检查镜像状态..."
                  
                  # 1. 检查目标镜像是否存在
                  if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                      # 检查创建时间
                      SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                      TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                          SRC_TIMESTAMP=$(date -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                          TARGET_TIMESTAMP=$(date -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                          
                          if [ "$TARGET_TIMESTAMP" -ge "$SRC_TIMESTAMP" ] || [ $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) -lt 120 ]; then
                              # 检查镜像大小
                              SRC_SIZE=$(skopeo inspect docker://$image --format '{{.Size}}' 2>/dev/null || echo "0")
                              TARGET_SIZE=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Size}}' 2>/dev/null || echo "0")
                              
                              if [ "$SRC_SIZE" != "0" ] && [ "$TARGET_SIZE" != "0" ]; then
                                  SIZE_DIFF=$((SRC_SIZE - TARGET_SIZE))
                                  SIZE_DIFF_PERCENT=$(( SIZE_DIFF * 100 / SRC_SIZE ))
                                  
                                  if [ ${SIZE_DIFF_PERCENT#-} -lt 10 ]; then
                                      echo "✅ 镜像已是最新版本，跳过: $image_name_tag"
                                      echo "RESULT:SKIP:$image_name_tag:已是最新" > "$result_file"
                                      return 0
                                  fi
                              else
                                  echo "✅ 镜像已是最新版本，跳过: $image_name_tag"
                                  echo "RESULT:SKIP:$image_name_tag:已是最新" > "$result_file"
                                  return 0
                              fi
                          fi
                      fi
                      
                      # 如果创建时间检查不确定，检查镜像层
                      SRC_LAYERS=$(skopeo inspect docker://$image --format '{{.Layers}}' 2>/dev/null || echo "")
                      TARGET_LAYERS=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Layers}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_LAYERS" ] && [ -n "$TARGET_LAYERS" ]; then
                          SRC_CLEANED=$(echo "$SRC_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                          TARGET_CLEANED=$(echo "$TARGET_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                          
                          if [ "$SRC_CLEANED" = "$TARGET_CLEANED" ]; then
                              echo "✅ 镜像层相同，跳过: $image_name_tag"
                              echo "RESULT:SKIP:$image_name_tag:镜像层相同" > "$result_file"
                              return 0
                          fi
                      fi
                  fi
                  
                  # 需要同步 - 执行实际的拉取、标记、推送操作
                  echo "🔄 需要同步镜像: $image_name_tag"
                  
                  # 拉取镜像
                  echo "步骤 1/3: 拉取源镜像..."
                  for attempt in {1..3}; do
                      if timeout 300 docker pull "$image" 2>&1 | tee -a "$log_file.pull"; then
                          echo "✅ 拉取成功 (第 $attempt 次尝试)"
                          break
                      elif [ $attempt -eq 3 ]; then
                          echo "❌ 拉取失败，达到最大重试次数"
                          echo "RESULT:FAIL:$image_name_tag:拉取失败" > "$result_file"
                          return 1
                      else
                          echo "⚠️ 拉取失败，等待重试..."
                          sleep $((attempt * 5))
                      fi
                  done
                  
                  # 标记镜像
                  echo "步骤 2/3: 重新标记镜像..."
                  if docker tag "$image" "$new_image"; then
                      echo "✅ 重标记成功"
                  else
                      echo "❌ 重标记失败"
                      echo "RESULT:FAIL:$image_name_tag:重命名失败" > "$result_file"
                      return 1
                  fi
                  
                  # 推送镜像
                  echo "步骤 3/3: 推送到阿里云..."
                  for attempt in {1..3}; do
                      if timeout 600 docker push "$new_image" 2>&1 | tee -a "$log_file.push"; then
                          echo "✅ 推送成功 (第 $attempt 次尝试)"
                          
                          # 清理该作业使用的镜像 (避免影响其他作业)
                          docker rmi "$image" "$new_image" 2>/dev/null || true
                          
                          echo "RESULT:SUCCESS:$image_name_tag" > "$result_file"
                          return 0
                      elif [ $attempt -eq 3 ]; then
                          echo "❌ 推送失败，达到最大重试次数"
                          echo "RESULT:FAIL:$image_name_tag:推送失败" > "$result_file"
                          return 1
                      else
                          echo "⚠️ 推送失败，等待重试..."
                          sleep $((attempt * 5))
                      fi
                  done
                  
              } > "$log_file" 2>&1
              
              # 确保结果文件存在
              if [ ! -f "$result_file" ]; then
                  echo "RESULT:FAIL:$image_name_tag:未返回结果" > "$result_file"
              fi
          }
          
          # 导出函数和必要的环境变量
          export -f process_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          
          # 第三步：使用 GNU Parallel 进行可靠的并行处理
          echo "=== 开始并行处理 ==="
          echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 清空旧结果
          rm -f /tmp/sync_results/*.result /tmp/sync_logs/*.log
          
          # 使用 parallel 处理，每个作业一个CPU核心，最大并发数4
          # --joblog 记录每个作业的状态，--progress 显示进度
          # --halt soon,fail=1 表示有1个失败就停止后续作业
          cat /tmp/image_config.txt | \
          parallel -j 4 --joblog /tmp/parallel_job.log --progress \
                  --colsep ' ' process_image "{\1} {\2} {\3} {\4}" "{#}" \
                  2>&1 | tee /tmp/parallel_output.log
          
          echo "结束时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "=== 并行处理完成 ==="
          
          # 第四步：汇总结果 (优化版)
          echo "=== 汇总处理结果 ==="
          
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          SKIP_COUNT=0
          SYNC_SUMMARY=""
          
          # 从 parallel 作业日志中读取结果
          if [ -f /tmp/parallel_job.log ]; then
              echo "📋 Parallel 作业日志摘要:"
              tail -n +2 /tmp/parallel_job.log | while read -r line; do
                  job_exit=$(echo "$line" | awk '{print $7}')
                  job_num=$(echo "$line" | awk '{print $1}')
                  
                  result_file="/tmp/sync_results/job_${job_num}.result"
                  if [ -f "$result_file" ]; then
                      result_line=$(cat "$result_file" 2>/dev/null | head -1)
                      if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                          img_name=$(echo "$result_line" | cut -d: -f3-)
                          SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ $img_name"
                          SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                      elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                          img_name=$(echo "$result_line" | cut -d: -f3-)
                          SYNC_SUMMARY="${SYNC_SUMMARY}\n⏭️ $img_name"
                          SKIP_COUNT=$((SKIP_COUNT + 1))
                      elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                          img_name=$(echo "$result_line" | cut -d: -f3-)
                          SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 $img_name"
                          FAILURE_COUNT=$((FAILURE_COUNT + 1))
                      fi
                  fi
              done
          fi
          
          # 备用方案：直接从结果文件读取
          if [ $SUCCESS_COUNT -eq 0 ] && [ $SKIP_COUNT -eq 0 ] && [ $FAILURE_COUNT -eq 0 ]; then
              echo "⚠️ 从作业日志未读取到结果，尝试从结果文件读取..."
              for result_file in /tmp/sync_results/*.result; do
                  [ -f "$result_file" ] || continue
                  result_line=$(cat "$result_file" 2>/dev/null | head -1)
                  if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                      img_name=$(echo "$result_line" | cut -d: -f3-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ $img_name"
                      SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                      img_name=$(echo "$result_line" | cut -d: -f3-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\n⏭️ $img_name"
                      SKIP_COUNT=$((SKIP_COUNT + 1))
                  elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                      img_name=$(echo "$result_line" | cut -d: -f3-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 $img_name"
                      FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  fi
              done
          fi
          
          echo "📊 最终统计结果:"
          echo "  成功: $SUCCESS_COUNT"
          echo "  跳过: $SKIP_COUNT"
          echo "  失败: $FAILURE_COUNT"
          
          # 写入环境变量供后续步骤使用
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "本次没有需要同步的新镜像"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # 检查是否有失败
          if [ "$FAILURE_COUNT" -gt 0 ]; then
              echo "❌ 有 $FAILURE_COUNT 个镜像同步失败，请检查日志"
              echo "详细日志位置: /tmp/sync_logs/"
              exit 1
          else
              echo "✅ 所有镜像处理完成"
          fi
      
      # 8. 清理 Docker 系统
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== 清理 Docker 系统 ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          echo "✅ 清理完成"
          echo "剩余磁盘空间:"
          df -h
      
      # 9. 发送 Webhook 通知 (保持不变)
      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "⚠️ 未配置 Webhook URL，跳过通知"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          K_COUNT=${{ env.SKIP_COUNT }}
          
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="❌ 阿里云镜像同步失败 (并行版)"
              CONTENT="⚠️ 警告：有 $F_COUNT 个镜像同步出现异常，请及时检查。"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="✅ 阿里云镜像同步成功 (并行版)"
              CONTENT="本次新增同步镜像如下："
          elif [ "$K_COUNT" -gt 0 ]; then
              TITLE="⏭️ 同步任务完成 (并行版 - 镜像已是最新)"
              CONTENT="所有镜像已是最新版本，无需同步。"
          else
              TITLE="☕ 同步任务完成 (并行版 - 无镜像需要处理)"
              CONTENT="检测到 images.txt 中无有效镜像需要处理。"
          fi
          
          RAW_TEXT=$(cat <<EOF
          $TITLE
          ━━━━━━━━━━━━━━━━
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          📊 统计: 成功 $S_COUNT | 跳过 $K_COUNT | 失败 $F_COUNT
          📅 时间: $(date '+%Y-%m-%d %H:%M:%S')
          🔗 详情: [查看 GitHub Action 日志](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          echo "发送 Webhook 通知..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "✅ 通知发送成功 (尝试 $i 次)"
                  break
              else
                  echo "⚠️ 通知发送失败，第 $i 次尝试"
                  sleep 2
              fi
          done
