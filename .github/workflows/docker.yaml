name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  schedule:
    # æ¯å¤© UTC æ—¶é—´ 00:00 (å³åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # åœ¨ Secrets ä¸­é…ç½®é£ä¹¦æˆ–ä¼å¾®åœ°å€

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
      - name: éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
        run: |
          echo "=== è¿è¡Œå™¨ç¯å¢ƒæŠ¥å‘Š ==="
          echo "è¿è¡Œå™¨ç¯å¢ƒï¼š${{ runner.environment }}"
          echo "è¿è¡Œå™¨åç§°ï¼š${{ runner.name }}"
          echo "è¿è¡Œå™¨æ ‡ç­¾ï¼š${{ toJson(runner.labels) }}"
          
          # å†³å®šæ€§æ£€æŸ¥ï¼šå¦‚æœæ˜¯è‡ªæ‰˜ç®¡ç¯å¢ƒï¼Œç«‹å³å¤±è´¥
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "âŒ ä¸¥é‡é”™è¯¯ï¼šæ£€æµ‹åˆ°è‡ªæ‰˜ç®¡è¿è¡Œå™¨ (self-hosted)ã€‚"
            echo "è¿™æ„å‘³ç€æ‚¨çš„ 'ubuntu-latest' æ ‡ç­¾ä»è¢«æŸä¸ªè‡ªæ‰˜ç®¡è¿è¡Œå™¨åŒ¹é…ã€‚"
            echo "è¯·ç«‹å³æ£€æŸ¥å¹¶åˆ é™¤æ‚¨è´¦æˆ·ä¸‹æ ‡è®°ä¸º 'ubuntu-latest' çš„è‡ªæ‰˜ç®¡è¿è¡Œå™¨ã€‚"
            exit 1
          fi
          
          echo "âœ… å½“å‰è¿è¡Œäº GitHub æ‰˜ç®¡çš„è¿è¡Œå™¨ (${{ runner.os }})ã€‚"
          echo "å½“å‰å·¥ä½œç›®å½•ï¼š$(pwd)"
          echo "å¯ç”¨ç£ç›˜ç©ºé—´ï¼š"
          df -h
      
      # 2. æ£€å‡ºä»£ç 
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. å®‰è£…å¿…éœ€å·¥å…·
      - name: Install required tools
        run: |
          echo "=== å®‰è£…å¿…éœ€å·¥å…· ==="
          sudo apt-get update
          sudo apt-get install -y skopeo jq parallel
          echo "âœ… skopeo ç‰ˆæœ¬: $(skopeo --version)"
          echo "âœ… jq ç‰ˆæœ¬: $(jq --version)"
          echo "âœ… parallel ç‰ˆæœ¬: $(parallel --version | head -1)"
      
      # 4. æœ€å¤§åŒ–æ„å»ºç©ºé—´
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. é‡å¯ Docker
      - name: Restart docker
        run: |
          echo "=== é‡å¯ Docker æœåŠ¡ ==="
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. ç™»å½•é˜¿é‡Œäº‘å®¹å™¨é•œåƒæœåŠ¡
      - name: Login to Aliyun Container Registry
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          echo "âœ… é˜¿é‡Œäº‘å®¹å™¨é•œåƒæœåŠ¡ç™»å½•æˆåŠŸ"
      
      # 7. æ‰¹é‡æ£€æŸ¥é•œåƒçŠ¶æ€ï¼ˆå¹¶è¡Œæ£€æŸ¥ï¼‰
      - name: Batch Check Images Status
        id: check_images
        run: |
          echo "=== æ‰¹é‡æ£€æŸ¥é•œåƒçŠ¶æ€ (å¹¶è¡Œæ£€æŸ¥) ==="
          
          # æ¸…ç©ºä¹‹å‰çš„è®°å½•æ–‡ä»¶
          > /tmp/need_sync.txt
          > /tmp/check_results.txt
          
          # è®°å½•æ€»é•œåƒæ•°ã€éœ€è¦åŒæ­¥æ•°ã€è·³è¿‡æ•°
          TOTAL_COUNT=0
          NEED_SYNC_COUNT=0
          SKIP_COUNT=0
          
          # ç¬¬ä¸€æ­¥ï¼šé¢„å¤„ç†ï¼Œæ‰¾å‡ºé‡åé•œåƒ
          echo "=== é¢„å¤„ç†ï¼šæ£€æµ‹é‡åé•œåƒ ==="
          declare -A duplicate_images
          declare -A temp_map
          
          # åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶å­˜å‚¨æœ‰æ•ˆçš„é•œåƒè¡Œ
          > /tmp/valid_images.txt
          
          # è¯»å–images.txtï¼Œè·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Šï¼ŒåŒæ—¶è®°å½•åŸå§‹è¡Œå·
          line_number=0
          while IFS= read -r line || [ -n "$line" ]; do
              line_number=$((line_number + 1))
              
              # å»é™¤é¦–å°¾ç©ºæ ¼
              line_trimmed=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              
              # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Šè¡Œ
              if [[ -z "$line_trimmed" ]]; then
                  continue
              fi
              
              if [[ "$line_trimmed" =~ ^# ]]; then
                  continue
              fi
              
              # è®°å½•æœ‰æ•ˆé•œåƒè¡Œå’Œè¡Œå·
              echo "$line_number|$line_trimmed" >> /tmp/valid_images.txt
              TOTAL_COUNT=$((TOTAL_COUNT + 1))
              
              # è§£æé•œåƒä¿¡æ¯ç”¨äºæ£€æµ‹é‡å
              # å¤„ç†å¯èƒ½çš„å‚æ•°ï¼ˆå¦‚--platformï¼‰
              source_image=""
              platform=""
              
              # ç®€å•çš„å‚æ•°è§£æ
              if echo "$line_trimmed" | grep -q " --platform "; then
                  source_image=$(echo "$line_trimmed" | awk -F' --platform ' '{print $1}' | xargs)
                  platform=$(echo "$line_trimmed" | awk -F' --platform ' '{print $2}' | xargs)
              else
                  source_image="$line_trimmed"
              fi
              
              # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
              image="${source_image%%@*}"
              
              # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              # è·å–å‘½åç©ºé—´
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
              if [[ -z "$name_space" ]]; then
                  name_space="library"
              fi
              
              # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # å¦‚æœé•œåƒå­˜åœ¨äºæ•°ç»„ä¸­ï¼Œåˆ™æ£€æŸ¥æ˜¯å¦æœ‰é‡åå†²çª
              if [[ -n "${temp_map[$image_name]}" ]]; then
                   # å¦‚æœ temp_map å·²ç»å­˜åœ¨é•œåƒåï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åŒä¸€å‘½åç©ºé—´
                   if [[ "${temp_map[$image_name]}" != "$name_space" ]]; then
                      duplicate_images[$image_name]="true"
                   fi
              else
                  # å­˜é•œåƒçš„å‘½åç©ºé—´
                  temp_map[$image_name]="$name_space"
              fi
          done < images.txt
          
          echo "âœ… é¢„å¤„ç†å®Œæˆï¼Œå‘ç° ${#duplicate_images[@]} ä¸ªé‡åé•œåƒ"
          echo "âœ… æ€»å…±å‘ç° $TOTAL_COUNT ä¸ªéœ€è¦æ£€æŸ¥çš„é•œåƒ"
          
          # ç¬¬äºŒæ­¥ï¼šåˆ›å»ºæ£€æŸ¥å‡½æ•°
          check_single_image() {
              local line_info="$1"
              
              # æ‹†åˆ†è¡Œå·å’Œé•œåƒè¡Œ
              IFS='|' read -r line_number line_trimmed <<< "$line_info"
              
              echo "=== æ£€æŸ¥ç¬¬ $line_number è¡Œ ==="
              echo "é•œåƒè¡Œ: $line_trimmed"
              
              # è§£æé•œåƒå’Œå¹³å°å‚æ•°
              source_image=""
              platform=""
              
              # å¤„ç†å¯èƒ½çš„å‚æ•°ï¼ˆå¦‚--platformï¼‰
              if echo "$line_trimmed" | grep -q " --platform "; then
                  source_image=$(echo "$line_trimmed" | awk -F' --platform ' '{print $1}' | xargs)
                  platform=$(echo "$line_trimmed" | awk -F' --platform ' '{print $2}' | xargs)
              else
                  source_image="$line_trimmed"
              fi
              
              # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
              image="${source_image%%@*}"
              
              # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              # è·å–å‘½åç©ºé—´
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
              if [[ -z "$name_space" ]]; then
                  name_space="library"
              fi
              
              # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # å¦‚æœå­˜åœ¨æ¶æ„ä¿¡æ¯ï¼Œå°†æ¶æ„ä¿¡æ¯æ‹¼åˆ°é•œåƒåç§°å‰é¢
              if [ -z "$platform" ]; then
                  platform_prefix=""
              else
                  platform_prefix="${platform//\//_}_"
              fi
              
              name_space_prefix=""
              # å¦‚æœé•œåƒåé‡åä¸”å‘½åç©ºé—´ä¸åŒ
              if [[ -n "${duplicate_images[$image_name]}" ]]; then
                 # å¦‚æœå‘½åç©ºé—´éç©ºï¼Œå°†å‘½åç©ºé—´åŠ åˆ°å‰ç¼€
                 name_space_prefix="${name_space}_"
              fi
              
              # æ„é€ ç›®æ ‡é•œåƒåç§°
              new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
              
              echo "åŸå§‹é•œåƒ: $image"
              echo "ç›®æ ‡é•œåƒ: $new_image"
              
              # æ£€æŸ¥é•œåƒçŠ¶æ€
              # 1. æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨
              if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  # ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œæ¯”è¾ƒé•œåƒåˆ›å»ºæ—¶é—´
                  # è·å–æºé•œåƒçš„åˆ›å»ºæ—¶é—´
                  SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                  
                  # è·å–ç›®æ ‡é•œåƒçš„åˆ›å»ºæ—¶é—´
                  TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                  
                  if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                      # è½¬æ¢ä¸ºæ—¶é—´æˆ³ï¼ˆUnixæ—¶é—´æˆ³ï¼Œå•ä½ï¼šç§’ï¼‰ï¼Œç¡®ä¿åœ¨åŒä¸€æ—¶åŒºï¼ˆUTCï¼‰æ¯”è¾ƒ
                      SRC_TIMESTAMP=$(date -u -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                      TARGET_TIMESTAMP=$(date -u -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                      
                      echo "æºé•œåƒåˆ›å»ºæ—¶é—´: $SRC_CREATED ($SRC_TIMESTAMP)"
                      echo "ç›®æ ‡é•œåƒåˆ›å»ºæ—¶é—´: $TARGET_CREATED ($TARGET_TIMESTAMP)"
                      
                      # æ¯”è¾ƒæ—¶é—´æˆ³ï¼šå¦‚æœDocker Hubçš„é•œåƒåˆ›å»ºæ—¶é—´æ™šäºé˜¿é‡Œäº‘çš„é•œåƒåˆ›å»ºæ—¶é—´ï¼Œåˆ™éœ€è¦åŒæ­¥
                      if [ "$SRC_TIMESTAMP" -gt "$TARGET_TIMESTAMP" ]; then
                          echo "ğŸ”„ éœ€è¦åŒæ­¥: $image_name_tag (æºé•œåƒè¾ƒæ–°)"
                          echo "$image|$new_image|$image_name_tag|$line_number" >> /tmp/need_sync.txt
                          echo "ç¬¬ $line_number è¡Œ: $image_name_tag (éœ€è¦åŒæ­¥ - æºé•œåƒè¾ƒæ–°)" >> /tmp/check_results.txt
                      elif [ "$SRC_TIMESTAMP" -eq "$TARGET_TIMESTAMP" ]; then
                          echo "âœ… è·³è¿‡: $image_name_tag (åˆ›å»ºæ—¶é—´ç›¸åŒ)"
                          echo "ç¬¬ $line_number è¡Œ: $image_name_tag (è·³è¿‡ - åˆ›å»ºæ—¶é—´ç›¸åŒ)" >> /tmp/check_results.txt
                      else
                          echo "âœ… è·³è¿‡: $image_name_tag (ç›®æ ‡é•œåƒå·²æ›´æ–°)"
                          echo "ç¬¬ $line_number è¡Œ: $image_name_tag (è·³è¿‡ - ç›®æ ‡é•œåƒå·²æ›´æ–°)" >> /tmp/check_results.txt
                      fi
                  else
                      # æ— æ³•è·å–åˆ›å»ºæ—¶é—´ï¼Œéœ€è¦åŒæ­¥
                      echo "ğŸ”„ éœ€è¦åŒæ­¥: $image_name_tag (æ— æ³•è·å–åˆ›å»ºæ—¶é—´)"
                      echo "$image|$new_image|$image_name_tag|$line_number" >> /tmp/need_sync.txt
                      echo "ç¬¬ $line_number è¡Œ: $image_name_tag (éœ€è¦åŒæ­¥ - æ— æ³•è·å–åˆ›å»ºæ—¶é—´)" >> /tmp/check_results.txt
                  fi
              else
                  # ç›®æ ‡é•œåƒä¸å­˜åœ¨ï¼Œéœ€è¦åŒæ­¥
                  echo "ğŸ”„ éœ€è¦åŒæ­¥: $image_name_tag (ç›®æ ‡é•œåƒä¸å­˜åœ¨)"
                  echo "$image|$new_image|$image_name_tag|$line_number" >> /tmp/need_sync.txt
                  echo "ç¬¬ $line_number è¡Œ: $image_name_tag (éœ€è¦åŒæ­¥ - ç›®æ ‡é•œåƒä¸å­˜åœ¨)" >> /tmp/check_results.txt
              fi
              
              echo ""
          }
          
          # å¯¼å‡ºå‡½æ•°å’Œå˜é‡ä»¥ä¾¿åœ¨å­shellä¸­ä½¿ç”¨
          export -f check_single_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          
          # å°†å…³è”æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²ä»¥ä¾¿ä¼ é€’
          duplicate_images_declare=$(declare -p duplicate_images)
          export duplicate_images_declare
          
          echo "=== å¼€å§‹å¹¶è¡Œæ£€æŸ¥é•œåƒçŠ¶æ€ (3ä¸ªå¹¶å‘) ==="
          
          # ä½¿ç”¨parallelå¹¶è¡Œå¤„ç†ï¼Œ3ä¸ªå¹¶å‘
          # æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å°†duplicate_imagesæ•°ç»„ä¼ é€’ç»™å­è¿›ç¨‹
          cat /tmp/valid_images.txt | parallel --jobs 3 '
            # åœ¨å­shellä¸­é‡å»ºå…³è”æ•°ç»„
            eval "$duplicate_images_declare"
            check_single_image "{}"
          '
          
          # ç»Ÿè®¡ç»“æœ
          if [ -f /tmp/need_sync.txt ]; then
              NEED_SYNC_COUNT=$(wc -l < /tmp/need_sync.txt | tr -d ' ')
          fi
          
          SKIP_COUNT=$((TOTAL_COUNT - NEED_SYNC_COUNT))
          
          echo ""
          echo "=== æ£€æŸ¥å®Œæˆ ==="
          echo "æ€»é•œåƒæ•°: $TOTAL_COUNT"
          echo "éœ€è¦åŒæ­¥: $NEED_SYNC_COUNT"
          echo "è·³è¿‡: $SKIP_COUNT"
          
          # è¾“å‡ºæ£€æŸ¥ç»“æœ
          if [ -f /tmp/check_results.txt ]; then
              echo "=== æ£€æŸ¥ç»“æœæ‘˜è¦ ==="
              cat /tmp/check_results.txt
          fi
          
          # è¾“å‡ºéœ€è¦åŒæ­¥çš„é•œåƒåˆ—è¡¨
          if [ -f /tmp/need_sync.txt ] && [ $NEED_SYNC_COUNT -gt 0 ]; then
              echo ""
              echo "=== éœ€è¦åŒæ­¥çš„é•œåƒåˆ—è¡¨ ==="
              awk -F'|' '{print "  " NR ". " $3 " (ç¬¬" $4 "è¡Œ)"}' /tmp/need_sync.txt
          fi
          
          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "TOTAL_COUNT=$TOTAL_COUNT" >> $GITHUB_ENV
          echo "NEED_SYNC_COUNT=$NEED_SYNC_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
      
      # 8. ä¸²è¡ŒåŒæ­¥é•œåƒï¼ˆç¬¬äºŒé˜¶æ®µï¼šä¾æ¬¡åŒæ­¥éœ€è¦æ›´æ–°çš„é•œåƒï¼‰
      - name: Serial Sync Images
        if: env.NEED_SYNC_COUNT != '0'
        run: |
          echo "=== ä¸²è¡ŒåŒæ­¥éœ€è¦æ›´æ–°çš„é•œåƒ ==="
          echo "éœ€è¦åŒæ­¥çš„é•œåƒæ•°é‡: $NEED_SYNC_COUNT"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          
          if [ ! -f /tmp/need_sync.txt ] || [ ! -s /tmp/need_sync.txt ]; then
              echo "âš ï¸ æ²¡æœ‰éœ€è¦åŒæ­¥çš„é•œåƒ"
              echo "SUCCESS_COUNT=0" >> $GITHUB_ENV
              echo "FAILURE_COUNT=0" >> $GITHUB_ENV
              echo 'SYNC_RESULT<<EOF' >> $GITHUB_ENV
              echo "æ²¡æœ‰éœ€è¦åŒæ­¥çš„é•œåƒ" >> $GITHUB_ENV
              echo 'EOF' >> $GITHUB_ENV
              exit 0
          fi
          
          # è¯»å–éœ€è¦åŒæ­¥çš„é•œåƒåˆ—è¡¨
          sync_index=0
          while IFS='|' read -r source_image target_image image_name_tag line_number; do
              sync_index=$((sync_index + 1))
              
              echo ""
              echo "========================================"
              echo "åŒæ­¥ $sync_index/$NEED_SYNC_COUNT: $image_name_tag (ç¬¬$line_numberè¡Œ)"
              echo "========================================"
              echo "åŸå§‹é•œåƒ: $source_image"
              echo "ç›®æ ‡é•œåƒ: $target_image"
              
              # æ‰§è¡ŒåŒæ­¥ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
              MAX_RETRIES=2
              RETRY_DELAY=5
              sync_success=false
              
              # 1. æ‹‰å–é•œåƒ
              for i in $(seq 1 $MAX_RETRIES); do
                  echo "æ­¥éª¤ 1/3: æ‹‰å–æºé•œåƒ (å°è¯• $i/$MAX_RETRIES)..."
                  if timeout 300 docker pull "$source_image"; then
                      sync_success=true
                      echo "  âœ… æ‹‰å–æˆåŠŸ"
                      break
                  else
                      echo "  âš ï¸ æ‹‰å–å¤±è´¥ï¼Œç­‰å¾… $RETRY_DELAY ç§’åé‡è¯•..."
                      sleep $RETRY_DELAY
                      sync_success=false
                  fi
              done
              
              if [ "$sync_success" = false ]; then
                  echo "  âŒ æ‹‰å–å¤±è´¥ (è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°)"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $image_name_tag (æ‹‰å–å¤±è´¥)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  echo "âŒ åŒæ­¥å¤±è´¥: $image_name_tag"
                  continue
              fi
              
              # 2. é‡æ–°æ ‡è®°é•œåƒ
              echo "æ­¥éª¤ 2/3: é‡æ–°æ ‡è®°é•œåƒ..."
              if docker tag "$source_image" "$target_image"; then
                  echo "  âœ… é‡æ ‡è®°æˆåŠŸ"
                  sync_success=true
              else
                  echo "  âŒ é‡æ ‡è®°å¤±è´¥"
                  # æ¸…ç†å·²æ‹‰å–çš„é•œåƒ
                  docker rmi "$source_image" 2>/dev/null || true
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $image_name_tag (é‡æ ‡è®°å¤±è´¥)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  echo "âŒ åŒæ­¥å¤±è´¥: $image_name_tag"
                  continue
              fi
              
              # 3. æ¨é€åˆ°é˜¿é‡Œäº‘
              push_success=false
              for i in $(seq 1 $MAX_RETRIES); do
                  echo "æ­¥éª¤ 3/3: æ¨é€åˆ°é˜¿é‡Œäº‘ (å°è¯• $i/$MAX_RETRIES)..."
                  if timeout 600 docker push "$target_image"; then
                      push_success=true
                      echo "  âœ… æ¨é€æˆåŠŸ"
                      break
                  else
                      echo "  âš ï¸ æ¨é€å¤±è´¥ï¼Œç­‰å¾… $RETRY_DELAY ç§’åé‡è¯•..."
                      sleep $RETRY_DELAY
                  fi
              done
              
              # æ¸…ç†æœ¬åœ°é•œåƒ
              docker rmi "$source_image" "$target_image" 2>/dev/null || true
              
              if [ "$push_success" = true ]; then
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ $image_name_tag"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  echo "âœ… åŒæ­¥å®Œæˆ: $image_name_tag"
              else
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $image_name_tag (æ¨é€å¤±è´¥)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  echo "âŒ åŒæ­¥å¤±è´¥: $image_name_tag"
              fi
              
              # æ¸…ç†Dockerç¼“å­˜ï¼Œé˜²æ­¢ç£ç›˜ç©ºé—´ä¸è¶³
              if [ $((sync_index % 5)) -eq 0 ] || [ $sync_index -eq $NEED_SYNC_COUNT ]; then
                  echo "æ¸…ç†Dockerç¼“å­˜..."
                  docker system prune -f 2>/dev/null || true
              fi
              
          done < /tmp/need_sync.txt
          
          echo ""
          echo "=== åŒæ­¥å®Œæˆ ==="
          echo "æˆåŠŸ: $SUCCESS_COUNT, å¤±è´¥: $FAILURE_COUNT"
          
          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "æœ¬æ¬¡æ²¡æœ‰éœ€è¦åŒæ­¥çš„æ–°é•œåƒ"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
      
      # 9. æ¸…ç† Docker ç³»ç»Ÿ
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== æ¸…ç† Docker ç³»ç»Ÿ ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          docker image prune -af 2>/dev/null || true
          echo "âœ… æ¸…ç†å®Œæˆ"
          echo "å‰©ä½™ç£ç›˜ç©ºé—´:"
          df -h
      
      # 10. å‘é€ Webhook é€šçŸ¥
      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "âš ï¸ æœªé…ç½® Webhook URLï¼Œè·³è¿‡é€šçŸ¥"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT || 0 }}
          F_COUNT=${{ env.FAILURE_COUNT || 0 }}
          K_COUNT=${{ env.SKIP_COUNT || 0 }}
          T_COUNT=${{ env.TOTAL_COUNT || 0 }}
          NEED_COUNT=${{ env.NEED_SYNC_COUNT || 0 }}
          
          # 1. åˆ¤å®šæ ‡é¢˜å’Œä¸»çŠ¶æ€
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="âš ï¸ é˜¿é‡Œäº‘é•œåƒåŒæ­¥éƒ¨åˆ†å¤±è´¥"
              if [ "$F_COUNT" -eq "$NEED_COUNT" ]; then
                  TITLE="âŒ é˜¿é‡Œäº‘é•œåƒåŒæ­¥å…¨éƒ¨å¤±è´¥"
              fi
              CONTENT="è­¦å‘Šï¼šæœ‰ $F_COUNT ä¸ªé•œåƒåŒæ­¥å‡ºç°å¼‚å¸¸ï¼Œè¯·åŠæ—¶æ£€æŸ¥ã€‚"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="âœ… é˜¿é‡Œäº‘é•œåƒåŒæ­¥æˆåŠŸ"
              CONTENT="æœ¬æ¬¡æ–°å¢åŒæ­¥é•œåƒå¦‚ä¸‹ï¼š"
          elif [ "$K_COUNT" -gt 0 ] && [ "$T_COUNT" -gt 0 ]; then
              TITLE="â­ï¸ åŒæ­¥ä»»åŠ¡å®Œæˆ (é•œåƒå·²æ˜¯æœ€æ–°)"
              CONTENT="åŸºäºåˆ›å»ºæ—¶é—´æ¯”è¾ƒï¼Œæ‰€æœ‰é•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œæ— éœ€åŒæ­¥ã€‚"
          else
              TITLE="â˜• åŒæ­¥ä»»åŠ¡å®Œæˆ (æ— é•œåƒéœ€è¦å¤„ç†)"
              CONTENT="æ£€æµ‹åˆ° images.txt ä¸­æ— æœ‰æ•ˆé•œåƒéœ€è¦å¤„ç†ã€‚"
          fi
          
          # 2. ç»„è£…æœ€ç»ˆæ–‡æœ¬
          RAW_TEXT=$(cat <<EOF
          $TITLE
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          ğŸ“Š ç»Ÿè®¡: æ€»æ•° $T_COUNT | éœ€è¦åŒæ­¥ $NEED_COUNT | æˆåŠŸ $S_COUNT | è·³è¿‡ $K_COUNT | å¤±è´¥ $F_COUNT
          ğŸ“… æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')
          ğŸ”— è¯¦æƒ…: [æŸ¥çœ‹ GitHub Action æ—¥å¿—](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          # 3. å‘é€é€šçŸ¥
          echo "å‘é€ Webhook é€šçŸ¥..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          # å°è¯•å‘é€ï¼Œæœ€å¤šé‡è¯•3æ¬¡
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "âœ… é€šçŸ¥å‘é€æˆåŠŸ (å°è¯• $i æ¬¡)"
                  break
              else
                  echo "âš ï¸ é€šçŸ¥å‘é€å¤±è´¥ï¼Œç¬¬ $i æ¬¡å°è¯•"
                  sleep 2
              fi
          done
