name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  schedule:
    # 每天 UTC 时间 00:00 (即北京时间 08:00) 运行
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # 在 Secrets 中配置飞书或企微地址

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. 验证运行器环境
      - name: 验证运行器环境
        run: |
          echo "=== 运行器环境报告 ==="
          echo "运行器环境：${{ runner.environment }}"
          echo "运行器名称：${{ runner.name }}"
          echo "运行器标签：${{ toJson(runner.labels) }}"
          
          # 决定性检查：如果是自托管环境，立即失败
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "❌ 严重错误：检测到自托管运行器 (self-hosted)。"
            echo "这意味着您的 'ubuntu-latest' 标签仍被某个自托管运行器匹配。"
            echo "请立即检查并删除您账户下标记为 'ubuntu-latest' 的自托管运行器。"
            exit 1
          fi
          
          echo "✅ 当前运行于 GitHub 托管的运行器 (${{ runner.os }})。"
          echo "当前工作目录：$(pwd)"
          echo "可用磁盘空间："
          df -h
      
      # 2. 检出代码
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. 安装必需工具
      - name: Install required tools
        run: |
          echo "=== 安装必需工具 ==="
          sudo apt-get update
          sudo apt-get install -y skopeo jq
          echo "✅ skopeo 版本: $(skopeo --version)"
          echo "✅ jq 版本: $(jq --version)"
      
      # 4. 最大化构建空间
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. 重启 Docker
      - name: Restart docker
        run: |
          echo "=== 重启 Docker 服务 ==="
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. 同步镜像到阿里云 (简化并行版本)
      - name: Sync and Push to Aliyun
        id: sync_step
        timeout-minutes: 30
        run: |
          echo "=== 开始同步镜像到阿里云 ==="
          
          # 登录阿里云容器镜像服务
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          SKIP_COUNT=0
          
          # 预处理：找出重名镜像并生成处理列表
          echo "=== 预处理：生成镜像处理列表 ==="
          
          # 创建处理列表文件
          PROCESS_LIST_FILE="/tmp/image_process_list.txt"
          > "$PROCESS_LIST_FILE"
          
          line_number=0
          while IFS= read -r line || [ -n "$line" ]; do
              line_number=$((line_number + 1))
              
              # 忽略空行与注释
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              
              echo "$line_number:$line" >> "$PROCESS_LIST_FILE"
          done < images.txt
          
          TOTAL_IMAGES=$(wc -l < "$PROCESS_LIST_FILE")
          echo "📊 总共需要处理的镜像数: $TOTAL_IMAGES"
          
          # 定义处理单个镜像的函数
          process_image() {
              local line_with_num="$1"
              local job_num="$2"
              
              # 解析行号和镜像信息
              local line_num=$(echo "$line_with_num" | cut -d: -f1)
              local line=$(echo "$line_with_num" | cut -d: -f2-)
              
              echo "=== 开始处理镜像 [$line_num/$TOTAL_IMAGES] (作业 $job_num) ==="
              
              # 获取原始镜像信息
              raw_image=$(echo "$line" | awk '{print $NF}')
              image="${raw_image%%@*}"
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              if [[ -z "$name_space" ]]; then
                  name_space="library"
              fi
              
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # 构造目标镜像名称（简化版本，不处理重名）
              new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$image_name_tag"
              
              echo "原始镜像: $image"
              echo "目标镜像: $new_image"
              
              # 检查镜像是否需要更新
              echo "检查镜像状态..."
              
              # 检查目标镜像是否存在
              if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  # 目标镜像存在，检查创建时间
                  SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                  TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                  
                  if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                      SRC_TIMESTAMP=$(date -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                      TARGET_TIMESTAMP=$(date -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                      
                      if [ "$TARGET_TIMESTAMP" -ge "$SRC_TIMESTAMP" ] || [ $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) -lt 120 ]; then
                          echo "✅ 创建时间相近，镜像已是最新版本，跳过: $image_name_tag"
                          echo "RESULT:SKIP:$image_name_tag:创建时间相近"
                          return 0
                      fi
                  fi
              fi
              
              echo "🔄 需要同步: $image_name_tag"
              
              # 执行同步
              for attempt in {1..3}; do
                  echo "  尝试第 $attempt 次拉取..."
                  if timeout 300 docker pull "$image"; then
                      echo "  ✅ 拉取成功"
                      break
                  elif [ $attempt -eq 3 ]; then
                      echo "  ❌ 拉取失败，达到最大重试次数"
                      echo "RESULT:FAIL:$image_name_tag:拉取失败"
                      return 1
                  else
                      sleep $((attempt * 5))
                  fi
              done
              
              if docker tag "$image" "$new_image"; then
                  echo "  ✅ 重标记成功"
              else
                  echo "  ❌ 重标记失败"
                  echo "RESULT:FAIL:$image_name_tag:重命名失败"
                  return 1
              fi
              
              for attempt in {1..3}; do
                  echo "  尝试第 $attempt 次推送..."
                  if timeout 600 docker push "$new_image"; then
                      echo "  ✅ 推送成功"
                      
                      # 清理本地镜像
                      docker rmi "$image" "$new_image" 2>/dev/null || true
                      
                      echo "RESULT:SUCCESS:$image_name_tag"
                      return 0
                  elif [ $attempt -eq 3 ]; then
                      echo "  ❌ 推送失败，达到最大重试次数"
                      echo "RESULT:FAIL:$image_name_tag:推送失败"
                      return 1
                  else
                      sleep $((attempt * 5))
                  fi
              done
              
              return 1
          }
          
          # 导出函数以便使用
          export -f process_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          
          echo "=== 开始并行处理镜像 ==="
          echo "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 创建结果文件
          RESULT_FILE="/tmp/sync_results.txt"
          > "$RESULT_FILE"
          
          # 使用 xargs 进行简单的并行处理
          # 这里设置最大并发数为 3 以避免资源耗尽
          MAX_JOBS=3
          job_counter=0
          
          while IFS= read -r line_with_num; do
              job_counter=$((job_counter + 1))
              
              # 处理镜像并在后台运行
              (
                  # 创建单独的日志文件
                  LOG_FILE="/tmp/job_${job_counter}.log"
                  {
                      echo "=== 作业 $job_counter 开始 ==="
                      process_image "$line_with_num" "$job_counter"
                      exit_code=$?
                      echo "=== 作业 $job_counter 结束，退出码: $exit_code ==="
                  } > "$LOG_FILE" 2>&1
                  
                  # 从日志中提取结果
                  if grep -q "^RESULT:" "$LOG_FILE"; then
                      result_line=$(grep "^RESULT:" "$LOG_FILE" | tail -1)
                      echo "$result_line" >> "$RESULT_FILE"
                      
                      case "$result_line" in
                          *RESULT:SUCCESS:*)
                              echo "✅ 作业 $job_counter 成功"
                              ;;
                          *RESULT:SKIP:*)
                              echo "⏭️ 作业 $job_counter 跳过"
                              ;;
                          *RESULT:FAIL:*)
                              echo "❌ 作业 $job_counter 失败"
                              ;;
                      esac
                  else
                      echo "⚠️ 作业 $job_counter 未返回结果" >> "$RESULT_FILE"
                  fi
                  
                  # 清理日志文件
                  # rm -f "$LOG_FILE"
              ) &
              
              # 控制并发数
              running_jobs=$(jobs -p | wc -l)
              while [ $running_jobs -ge $MAX_JOBS ]; do
                  sleep 1
                  running_jobs=$(jobs -p | wc -l)
              done
              
          done < "$PROCESS_LIST_FILE"
          
          # 等待所有后台作业完成
          echo "等待所有作业完成..."
          wait
          
          echo "结束时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "=== 并行处理完成 ==="
          
          # 统计结果
          SUCCESS_COUNT=$(grep -c "RESULT:SUCCESS:" "$RESULT_FILE" || true)
          SKIP_COUNT=$(grep -c "RESULT:SKIP:" "$RESULT_FILE" || true)
          FAILURE_COUNT=$(grep -c "RESULT:FAIL:" "$RESULT_FILE" || true)
          
          # 构建结果摘要
          SYNC_SUMMARY=""
          while IFS= read -r result_line; do
              if [[ "$result_line" == RESULT:SUCCESS:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ $img_name"
              elif [[ "$result_line" == RESULT:SKIP:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n⏭️ $img_name"
              elif [[ "$result_line" == RESULT:FAIL:* ]]; then
                  img_name=$(echo "$result_line" | cut -d: -f3-)
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 $img_name"
              fi
          done < "$RESULT_FILE"
          
          echo "📊 统计结果:"
          echo "  成功: $SUCCESS_COUNT"
          echo "  跳过: $SKIP_COUNT"
          echo "  失败: $FAILURE_COUNT"
          
          # 写入环境变量
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "本次没有需要同步的新镜像"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # 清理临时文件
          rm -f "$PROCESS_LIST_FILE" "$RESULT_FILE"
          
          # 如果有失败，返回非零退出码
          if [ "$FAILURE_COUNT" -gt 0 ]; then
              echo "⚠️ 有 $FAILURE_COUNT 个镜像同步失败"
              exit 1
          fi
      
      # 7. 清理 Docker 系统
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== 清理 Docker 系统 ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          echo "✅ 清理完成"
          echo "剩余磁盘空间:"
          df -h
      
      # 8. 发送 Webhook 通知
      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "⚠️ 未配置 Webhook URL，跳过通知"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          K_COUNT=${{ env.SKIP_COUNT }}
          
          # 1. 判定标题和主状态
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="❌ 阿里云镜像同步失败"
              CONTENT="⚠️ 警告：有 $F_COUNT 个镜像同步出现异常，请及时检查。"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="✅ 阿里云镜像同步成功"
              CONTENT="本次新增同步镜像如下："
          elif [ "$K_COUNT" -gt 0 ]; then
              TITLE="⏭️ 同步任务完成 (镜像已是最新)"
              CONTENT="所有镜像已是最新版本，无需同步。"
          else
              TITLE="☕ 同步任务完成 (无镜像需要处理)"
              CONTENT="检测到 images.txt 中无有效镜像需要处理。"
          fi
          
          # 2. 组装最终文本
          RAW_TEXT=$(cat <<EOF
          $TITLE
          ━━━━━━━━━━━━━━━━
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          📊 统计: 成功 $S_COUNT | 跳过 $K_COUNT | 失败 $F_COUNT
          📅 时间: $(date '+%Y-%m-%d %H:%M:%S')
          🔗 详情: [查看 GitHub Action 日志](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          # 3. 发送通知
          echo "发送 Webhook 通知..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          # 尝试发送，最多重试3次
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "✅ 通知发送成功 (尝试 $i 次)"
                  break
              else
                  echo "⚠️ 通知发送失败，第 $i 次尝试"
                  sleep 2
              fi
          done
