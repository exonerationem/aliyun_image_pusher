name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  schedule:
    # æ¯å¤© UTC æ—¶é—´ 00:00 (å³åŒ—äº¬æ—¶é—´ 08:00) è¿è¡Œ
    - cron: '0 */12 * * *'
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # åœ¨ Secrets ä¸­é…ç½®é£ä¹¦æˆ–ä¼å¾®åœ°å€
  # å¹¶è¡Œå¤„ç†é…ç½®
  MAX_CONCURRENT_JOBS: "5"  # åŒæ—¶å¤„ç†çš„æœ€å¤§é•œåƒæ•°ï¼Œæ ¹æ®è¿è¡Œå™¨æ€§èƒ½è°ƒæ•´

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      # 1. éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
      - name: éªŒè¯è¿è¡Œå™¨ç¯å¢ƒ
        run: |
          echo "=== è¿è¡Œå™¨ç¯å¢ƒæŠ¥å‘Š ==="
          echo "è¿è¡Œå™¨ç¯å¢ƒï¼š${{ runner.environment }}"
          echo "è¿è¡Œå™¨åç§°ï¼š${{ runner.name }}"
          echo "è¿è¡Œå™¨æ ‡ç­¾ï¼š${{ toJson(runner.labels) }}"
          
          # å†³å®šæ€§æ£€æŸ¥ï¼šå¦‚æœæ˜¯è‡ªæ‰˜ç®¡ç¯å¢ƒï¼Œç«‹å³å¤±è´¥
          if [ "${{ runner.environment }}" == "self-hosted" ]; then
            echo "âŒ ä¸¥é‡é”™è¯¯ï¼šæ£€æµ‹åˆ°è‡ªæ‰˜ç®¡è¿è¡Œå™¨ (self-hosted)ã€‚"
            echo "è¿™æ„å‘³ç€æ‚¨çš„ 'ubuntu-latest' æ ‡ç­¾ä»è¢«æŸä¸ªè‡ªæ‰˜ç®¡è¿è¡Œå™¨åŒ¹é…ã€‚"
            echo "è¯·ç«‹å³æ£€æŸ¥å¹¶åˆ é™¤æ‚¨è´¦æˆ·ä¸‹æ ‡è®°ä¸º 'ubuntu-latest' çš„è‡ªæ‰˜ç®¡è¿è¡Œå™¨ã€‚"
            exit 1
          fi
          
          echo "âœ… å½“å‰è¿è¡Œäº GitHub æ‰˜ç®¡çš„è¿è¡Œå™¨ (${{ runner.os }})ã€‚"
          echo "å½“å‰å·¥ä½œç›®å½•ï¼š$(pwd)"
          echo "å¯ç”¨ç£ç›˜ç©ºé—´ï¼š"
          df -h
      
      # 2. æ£€å‡ºä»£ç 
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # 3. å®‰è£…å¿…éœ€å·¥å…·ï¼ˆæ·»åŠ  parallel å·¥å…·ï¼‰
      - name: Install required tools
        run: |
          echo "=== å®‰è£…å¿…éœ€å·¥å…· ==="
          for i in {1..3}; do
            if sudo apt-get update && sudo apt-get install -y skopeo jq parallel; then
              echo "âœ… å·¥å…·å®‰è£…æˆåŠŸ (å°è¯• $i æ¬¡)"
              break
            else
              echo "âš ï¸ å·¥å…·å®‰è£…å¤±è´¥ï¼Œç¬¬ $i æ¬¡å°è¯•"
              if [ $i -eq 3 ]; then
                echo "âŒ å·¥å…·å®‰è£…å¤±è´¥ï¼Œé€€å‡º"
                exit 1
              fi
              sleep 5
            fi
          done
          echo "âœ… skopeo ç‰ˆæœ¬: $(skopeo --version)"
          echo "âœ… jq ç‰ˆæœ¬: $(jq --version)"
          echo "âœ… parallel ç‰ˆæœ¬: $(parallel --version | head -1)"
      
      # 4. æœ€å¤§åŒ–æ„å»ºç©ºé—´
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'
      
      # 5. é‡å¯ Docker å¹¶è®¾ç½®å¹¶è¡Œåº¦
      - name: Restart docker
        run: |
          echo "=== é‡å¯ Docker æœåŠ¡ ==="
          # è®¾ç½® Docker å¹¶è¡Œä¸‹è½½å’Œä¸Šä¼ 
          echo '{"max-concurrent-downloads": 5, "max-concurrent-uploads": 5}' | sudo tee /etc/docker/daemon.json
          sudo service docker restart
          sleep 5
          docker info
      
      # 6. å¹¶è¡ŒåŒæ­¥é•œåƒåˆ°é˜¿é‡Œäº‘
      - name: Parallel Sync to Aliyun
        id: sync_step
        timeout-minutes: 45  # è®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œè€ƒè™‘å¹¶è¡Œå¤„ç†
        run: |
          echo "=== å¼€å§‹å¹¶è¡ŒåŒæ­¥é•œåƒåˆ°é˜¿é‡Œäº‘ ==="
          
          # ç™»å½•é˜¿é‡Œäº‘å®¹å™¨é•œåƒæœåŠ¡
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          # åˆ›å»ºä¸´æ—¶ç›®å½•å­˜æ”¾ç»“æœ
          mkdir -p /tmp/sync_results
          mkdir -p /tmp/sync_logs
          
          # ç»Ÿè®¡é•œåƒæ€»æ•°
          TOTAL_IMAGES=$(grep -v '^\s*#' images.txt | grep -v '^\s*$' | wc -l)
          echo "ğŸ“Š æ€»å…±éœ€è¦å¤„ç†çš„é•œåƒæ•°: $TOTAL_IMAGES"
          echo "âš¡ å¹¶è¡Œå¤„ç†æ•°: $MAX_CONCURRENT_JOBS"
          
          # ç¬¬ä¸€æ­¥ï¼šé¢„å¤„ç†ï¼Œæ‰¾å‡ºé‡åé•œåƒ
          echo "=== é¢„å¤„ç†ï¼šæ£€æµ‹é‡åé•œåƒ ==="
          declare -A duplicate_images
          declare -A temp_map
          
          while IFS= read -r line || [ -n "$line" ]; do
              # å¿½ç•¥ç©ºè¡Œä¸æ³¨é‡Š
              [[ -z "$line" ]] && continue
              if echo "$line" | grep -q '^\s*#'; then
                  continue
              fi
              
              # è·å–é•œåƒçš„å®Œæ•´åç§°
              raw_image=$(echo "$line" | awk '{print $NF}')
              # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
              image="${raw_image%%@*}"
              # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              # è·å–å‘½åç©ºé—´
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              
              # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
              if [[ -z "$name_space" ]]; then
                  name_space="library"
              fi
              
              # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # å¦‚æœé•œåƒå­˜åœ¨äºæ•°ç»„ä¸­ï¼Œåˆ™æ£€æŸ¥æ˜¯å¦æœ‰é‡åå†²çª
              if [[ -n "${temp_map[$image_name]}" ]]; then
                   # å¦‚æœ temp_map å·²ç»å­˜åœ¨é•œåƒåï¼Œåˆ¤æ–­æ˜¯ä¸æ˜¯åŒä¸€å‘½åç©ºé—´
                   if [[ "${temp_map[$image_name]}" != "$name_space" ]]; then
                      duplicate_images[$image_name]="true"
                   fi
              else
                  # å­˜é•œåƒçš„å‘½åç©ºé—´
                  temp_map[$image_name]="$name_space"
              fi
          done < images.txt
          
          echo "âœ… é¢„å¤„ç†å®Œæˆï¼Œå‘ç° ${#duplicate_images[@]} ä¸ªé‡åé•œåƒ"
          
          # å‡†å¤‡é•œåƒåˆ—è¡¨æ–‡ä»¶ï¼ˆè¿‡æ»¤æ³¨é‡Šå’Œç©ºè¡Œï¼‰
          grep -v '^\s*#' images.txt | grep -v '^\s*$' > /tmp/image_list.txt
          
          # ç¬¬äºŒæ­¥ï¼šå¹¶è¡Œå¤„ç†é•œåƒ
          echo "=== å¼€å§‹å¹¶è¡Œå¤„ç†é•œåƒ ==="
          echo "å¼€å§‹æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # å®šä¹‰å¤„ç†å•ä¸ªé•œåƒçš„å‡½æ•°
          process_single_image() {
              local line="$1"
              local line_number="$2"
              local total_images="$3"
              local job_id="$4"
              
              # åˆ›å»ºæ—¥å¿—æ–‡ä»¶
              local log_file="/tmp/sync_logs/job_${job_id}.log"
              
              {
                  echo "=== å¼€å§‹å¤„ç†é•œåƒ [$line_number/$total_images] ==="
                  echo "åŸå§‹è¡Œ: $line"
                  
                  # è·å–åŸå§‹é•œåƒä¿¡æ¯
                  raw_image=$(echo "$line" | awk '{print $NF}')
                  # ç§»é™¤ @sha256: ç­‰æ‘˜è¦ä¿¡æ¯
                  image="${raw_image%%@*}"
                  
                  # è·å–é•œåƒå:ç‰ˆæœ¬å· ä¾‹å¦‚ nginx:1.25.3
                  image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
                  # è·å–å‘½åç©ºé—´
                  name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
                  
                  # å¦‚æœå‘½åç©ºé—´ä¸ºç©ºï¼Œä½¿ç”¨ç‰¹å®šæ ‡è®°
                  if [[ -z "$name_space" ]]; then
                      name_space="library"
                  fi
                  
                  # è·å–é•œåƒåï¼ˆä¸å«æ ‡ç­¾ï¼‰ä¾‹å¦‚ nginx
                  image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
                  
                  # æå–å¹³å°æ¶æ„ä¿¡æ¯
                  platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
                  
                  # å¦‚æœå­˜åœ¨æ¶æ„ä¿¡æ¯ï¼Œå°†æ¶æ„ä¿¡æ¯æ‹¼åˆ°é•œåƒåç§°å‰é¢
                  if [ -z "$platform" ]; then
                      platform_prefix=""
                  else
                      platform_prefix="${platform//\//_}_"
                  fi
                  
                  name_space_prefix=""
                  # å¦‚æœé•œåƒåé‡åä¸”å‘½åç©ºé—´ä¸åŒ
                  if [[ -n "${duplicate_images[$image_name]}" ]]; then
                     # å¦‚æœå‘½åç©ºé—´éç©ºï¼Œå°†å‘½åç©ºé—´åŠ åˆ°å‰ç¼€
                     name_space_prefix="${name_space}_"
                  fi
                  
                  # æ„é€ ç›®æ ‡é•œåƒåç§°
                  new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
                  
                  echo "åŸå§‹é•œåƒ: $image"
                  echo "ç›®æ ‡é•œåƒ: $new_image"
                  echo "å¹³å°æ¶æ„: ${platform:-é»˜è®¤}"
                  echo "å‘½åç©ºé—´: $name_space"
                  
                  # ========== æ£€æŸ¥é•œåƒæ˜¯å¦éœ€è¦æ›´æ–° ==========
                  echo "æ£€æŸ¥é•œåƒçŠ¶æ€..."
                  
                  # 1. æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨
                  echo "æ£€æŸ¥ç›®æ ‡é•œåƒæ˜¯å¦å­˜åœ¨..."
                  if skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                      # ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œé¦–å…ˆæ£€æŸ¥åˆ›å»ºæ—¶é—´
                      echo "ç›®æ ‡é•œåƒå­˜åœ¨ï¼Œæ£€æŸ¥åˆ›å»ºæ—¶é—´..."
                      
                      # è·å–æºé•œåƒçš„åˆ›å»ºæ—¶é—´
                      SRC_CREATED=$(skopeo inspect docker://$image --format '{{.Created}}' 2>/dev/null || echo "")
                      # è·å–ç›®æ ‡é•œåƒçš„åˆ›å»ºæ—¶é—´
                      TARGET_CREATED=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Created}}' 2>/dev/null || echo "")
                      
                      if [ -n "$SRC_CREATED" ] && [ -n "$TARGET_CREATED" ]; then
                          # è½¬æ¢ä¸ºæ—¶é—´æˆ³æ¯”è¾ƒ
                          SRC_TIMESTAMP=$(date -d "$SRC_CREATED" +%s 2>/dev/null || echo "0")
                          TARGET_TIMESTAMP=$(date -d "$TARGET_CREATED" +%s 2>/dev/null || echo "0")
                          
                          # å¦‚æœç›®æ ‡é•œåƒåˆ›å»ºæ—¶é—´æ¯”æºé•œåƒæ™šæˆ–ç›¸åŒï¼ˆç›¸å·®åœ¨120ç§’å†…ï¼‰ï¼Œåˆ™è®¤ä¸ºæ˜¯æœ€æ–°
                          if [ "$TARGET_TIMESTAMP" -ge "$SRC_TIMESTAMP" ] || [ $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) -lt 120 ]; then
                              echo "âœ… åˆ›å»ºæ—¶é—´ç›¸è¿‘ï¼Œé•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡: $image_name_tag"
                              echo "  æºåˆ›å»ºæ—¶é—´: $SRC_CREATED ($SRC_TIMESTAMP)"
                              echo "  ç›®æ ‡åˆ›å»ºæ—¶é—´: $TARGET_CREATED ($TARGET_TIMESTAMP)"
                              echo "SKIP:$image_name_tag:åˆ›å»ºæ—¶é—´ç›¸è¿‘"
                              return 0
                          else
                              echo "ğŸ”„ ç›®æ ‡é•œåƒåˆ›å»ºæ—¶é—´è¾ƒæ—© (å·® $((SRC_TIMESTAMP - TARGET_TIMESTAMP)) ç§’)ï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                          fi
                      else
                          echo "â„¹ï¸ æ— æ³•è·å–åˆ›å»ºæ—¶é—´ï¼Œæ£€æŸ¥é•œåƒå±‚..."
                          
                          # æ£€æŸ¥é•œåƒå±‚ä½œä¸ºåå¤‡æ–¹æ¡ˆ
                          SRC_LAYERS=$(skopeo inspect docker://$image --format '{{.Layers}}' 2>/dev/null || echo "")
                          TARGET_LAYERS=$(skopeo inspect docker://$new_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" --format '{{.Layers}}' 2>/dev/null || echo "")
                          
                          if [ -n "$SRC_LAYERS" ] && [ -n "$TARGET_LAYERS" ]; then
                              # å»é™¤æ–¹æ‹¬å·å¹¶æ’åºï¼Œç„¶åæ¯”è¾ƒ
                              SRC_CLEANED=$(echo "$SRC_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                              TARGET_CLEANED=$(echo "$TARGET_LAYERS" | tr -d '[]' | tr ' ' '\n' | sort | tr '\n' ' ' | xargs)
                              
                              if [ "$SRC_CLEANED" = "$TARGET_CLEANED" ]; then
                                  echo "âœ… é•œåƒå±‚ç›¸åŒï¼Œé•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œè·³è¿‡: $image_name_tag"
                                  echo "SKIP:$image_name_tag:é•œåƒå±‚ç›¸åŒ"
                                  return 0
                              else
                                  echo "ğŸ”„ é•œåƒå±‚ä¸åŒï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                              fi
                          else
                              echo "ğŸ”„ æ— æ³•è·å–é•œåƒä¿¡æ¯ï¼Œå‡ºäºå®‰å…¨è€ƒè™‘æ‰§è¡ŒåŒæ­¥: $image_name_tag"
                          fi
                      fi
                  else
                      echo "ğŸ”„ ç›®æ ‡é•œåƒä¸å­˜åœ¨ï¼Œéœ€è¦åŒæ­¥: $image_name_tag"
                  fi
                  # ========== æ£€æŸ¥ç»“æŸ ==========
                  
                  echo "å¼€å§‹åŒæ­¥é•œåƒ..."
                  
                  # æ‰§è¡ŒåŒæ­¥ï¼ˆå¸¦è¶…æ—¶å’Œè¯¦ç»†æ—¥å¿—ï¼‰
                  # 1. æ‹‰å–é•œåƒï¼ˆä½¿ç”¨é‡è¯•æœºåˆ¶ï¼‰
                  echo "æ­¥éª¤ 1/3: æ‹‰å–æºé•œåƒ..."
                  PULL_SUCCESS=false
                  for attempt in {1..3}; do
                      echo "  å°è¯•æ‹‰å–ç¬¬ $attempt æ¬¡..."
                      if timeout 300 docker pull "$image"; then
                          echo "  âœ… æ‹‰å–æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          PULL_SUCCESS=true
                          break
                      else
                          echo "  âš ï¸ æ‹‰å–å¤±è´¥ (ç¬¬ $attempt æ¬¡å°è¯•)"
                          if [ $attempt -lt 3 ]; then
                              sleep $((attempt * 5))
                          fi
                      fi
                  done
                  
                  if [ "$PULL_SUCCESS" = false ]; then
                      echo "  âŒ æ‹‰å–å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                      echo "FAIL:$image_name_tag:æ‹‰å–å¤±è´¥"
                      return 1
                  fi
                      
                  # 2. é‡æ–°æ ‡è®°é•œåƒ
                  echo "æ­¥éª¤ 2/3: é‡æ–°æ ‡è®°é•œåƒ..."
                  if docker tag "$image" "$new_image"; then
                      echo "  âœ… é‡æ ‡è®°æˆåŠŸ"
                      
                      # 3. æ¨é€åˆ°é˜¿é‡Œäº‘ï¼ˆä½¿ç”¨é‡è¯•æœºåˆ¶ï¼‰
                      echo "æ­¥éª¤ 3/3: æ¨é€åˆ°é˜¿é‡Œäº‘..."
                      PUSH_SUCCESS=false
                      for attempt in {1..3}; do
                          echo "  å°è¯•æ¨é€ç¬¬ $attempt æ¬¡..."
                          if timeout 600 docker push "$new_image"; then
                              echo "  âœ… æ¨é€æˆåŠŸ (ç¬¬ $attempt æ¬¡å°è¯•)"
                              PUSH_SUCCESS=true
                              break
                          else
                              echo "  âš ï¸ æ¨é€å¤±è´¥ (ç¬¬ $attempt æ¬¡å°è¯•)"
                              if [ $attempt -lt 3 ]; then
                                  sleep $((attempt * 5))
                              fi
                          fi
                      done
                      
                      if [ "$PUSH_SUCCESS" = false ]; then
                          echo "  âŒ æ¨é€å¤±è´¥ï¼Œè¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°"
                          echo "FAIL:$image_name_tag:æ¨é€å¤±è´¥"
                          return 1
                      else
                          # æ¸…ç†æœ¬åœ°é•œåƒ
                          docker rmi "$image" "$new_image" 2>/dev/null || true
                          echo "SUCCESS:$image_name_tag"
                          return 0
                      fi
                  else
                      echo "  âŒ é‡æ ‡è®°å¤±è´¥"
                      echo "FAIL:$image_name_tag:é‡å‘½åå¤±è´¥"
                      return 1
                  fi
              } > "$log_file" 2>&1
              
              # è¿”å›æ—¥å¿—æ–‡ä»¶è·¯å¾„
              echo "$log_file"
          }
          
          # å¯¼å‡ºå‡½æ•°ä»¥ä¾¿ parallel ä½¿ç”¨
          export -f process_single_image
          export ALIYUN_REGISTRY ALIYUN_NAME_SPACE ALIYUN_REGISTRY_USER ALIYUN_REGISTRY_PASSWORD
          
          # å¯¼å‡ºå…³è”æ•°ç»„åˆ°ç¯å¢ƒå˜é‡ï¼ˆä¾¿äºå­è¿›ç¨‹ä½¿ç”¨ï¼‰
          for key in "${!duplicate_images[@]}"; do
              export "duplicate_images_$key=${duplicate_images[$key]}"
          done
          
          # ä½¿ç”¨ parallel å¹¶è¡Œå¤„ç†
          # --joblog è®°å½•ä½œä¸šæ—¥å¿—ï¼Œ--progress æ˜¾ç¤ºè¿›åº¦ï¼Œ--tag æ ‡è®°è¾“å‡º
          # --retries 3 å¤±è´¥é‡è¯•3æ¬¡ï¼Œ--timeout 1800 å•ä¸ªä½œä¸šè¶…æ—¶30åˆ†é’Ÿ
          parallel --joblog /tmp/sync_results/joblog.txt \
                  --progress \
                  --tag \
                  --retries 3 \
                  --timeout 1800 \
                  --jobs "$MAX_CONCURRENT_JOBS" \
                  --bar \
                  'process_single_image "{1}" "{#}" "'"$TOTAL_IMAGES"'" "{#}"' :::: /tmp/image_list.txt
          
          echo "ç»“æŸæ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "=== å¹¶è¡Œå¤„ç†å®Œæˆ ==="
          
          # ç¬¬ä¸‰æ­¥ï¼šæ±‡æ€»ç»“æœ
          echo "=== æ±‡æ€»å¤„ç†ç»“æœ ==="
          
          # æ”¶é›†æ‰€æœ‰æ—¥å¿—æ–‡ä»¶
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          SKIP_COUNT=0
          SYNC_SUMMARY=""
          
          # ä»æ—¥å¿—æ–‡ä»¶ä¸­æå–è¯¦ç»†ç»“æœ
          for log_file in /tmp/sync_logs/*.log 2>/dev/null; do
              if [ -f "$log_file" ]; then
                  # æå–æœ€åå‡ è¡Œç»“æœ
                  if tail -10 "$log_file" | grep -q "^SUCCESS:"; then
                      img_name=$(tail -10 "$log_file" | grep "^SUCCESS:" | cut -d: -f2-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ $img_name"
                      SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  elif tail -10 "$log_file" | grep -q "^SKIP:"; then
                      img_name=$(tail -10 "$log_file" | grep "^SKIP:" | cut -d: -f2-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\nâ­ï¸ $img_name"
                      SKIP_COUNT=$((SKIP_COUNT + 1))
                  elif tail -10 "$log_file" | grep -q "^FAIL:"; then
                      img_name=$(tail -10 "$log_file" | grep "^FAIL:" | cut -d: -f2-)
                      SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ $img_name"
                      FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  fi
              fi
          done
          
          echo "ğŸ“Š ç»Ÿè®¡ç»“æœ:"
          echo "  æˆåŠŸ: $SUCCESS_COUNT"
          echo "  è·³è¿‡: $SKIP_COUNT"
          echo "  å¤±è´¥: $FAILURE_COUNT"
          
          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          echo "SKIP_COUNT=$SKIP_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            if [ -n "$SYNC_SUMMARY" ]; then
                echo -e "$SYNC_SUMMARY"
            else
                echo "æœ¬æ¬¡æ²¡æœ‰éœ€è¦åŒæ­¥çš„æ–°é•œåƒ"
            fi
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # æ˜¾ç¤ºä½œä¸šæ—¥å¿—æ‘˜è¦
          echo "=== ä½œä¸šæ—¥å¿—æ‘˜è¦ ==="
          if [ -f /tmp/sync_results/joblog.txt ]; then
              tail -20 /tmp/sync_results/joblog.txt
          fi
      
      # 7. æ¸…ç† Docker ç³»ç»Ÿ
      - name: Clean up Docker system
        if: always()
        run: |
          echo "=== æ¸…ç† Docker ç³»ç»Ÿ ==="
          docker system prune -af 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          docker volume prune -f 2>/dev/null || true
          echo "âœ… æ¸…ç†å®Œæˆ"
          echo "å‰©ä½™ç£ç›˜ç©ºé—´:"
          df -h
      
      # 8. å‘é€ Webhook é€šçŸ¥
      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then
            echo "âš ï¸ æœªé…ç½® Webhook URLï¼Œè·³è¿‡é€šçŸ¥"
            exit 0
          fi
          
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          K_COUNT=${{ env.SKIP_COUNT }}
          
          # 1. åˆ¤å®šæ ‡é¢˜å’Œä¸»çŠ¶æ€
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="âŒ é˜¿é‡Œäº‘é•œåƒåŒæ­¥å¤±è´¥"
              CONTENT="âš ï¸ è­¦å‘Šï¼šæœ‰ $F_COUNT ä¸ªé•œåƒåŒæ­¥å‡ºç°å¼‚å¸¸ï¼Œè¯·åŠæ—¶æ£€æŸ¥ã€‚"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="âœ… é˜¿é‡Œäº‘é•œåƒåŒæ­¥æˆåŠŸ"
              CONTENT="æœ¬æ¬¡æ–°å¢åŒæ­¥é•œåƒå¦‚ä¸‹ï¼š"
          elif [ "$K_COUNT" -gt 0 ]; then
              TITLE="â­ï¸ åŒæ­¥ä»»åŠ¡å®Œæˆ (é•œåƒå·²æ˜¯æœ€æ–°)"
              CONTENT="æ‰€æœ‰é•œåƒå·²æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œæ— éœ€åŒæ­¥ã€‚"
          else
              TITLE="â˜• åŒæ­¥ä»»åŠ¡å®Œæˆ (æ— é•œåƒéœ€è¦å¤„ç†)"
              CONTENT="æ£€æµ‹åˆ° images.txt ä¸­æ— æœ‰æ•ˆé•œåƒéœ€è¦å¤„ç†ã€‚"
          fi
          
          # 2. ç»„è£…æœ€ç»ˆæ–‡æœ¬
          RAW_TEXT=$(cat <<EOF
          $TITLE
          â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
          $CONTENT
          ${{ env.SYNC_RESULT }}
          
          ğŸ“Š ç»Ÿè®¡: æˆåŠŸ $S_COUNT | è·³è¿‡ $K_COUNT | å¤±è´¥ $F_COUNT
          âš¡ å¹¶è¡Œ: ${{ env.MAX_CONCURRENT_JOBS }} ä¸ªå¹¶å‘
          ğŸ“… æ—¶é—´: $(date '+%Y-%m-%d %H:%M:%S')
          ğŸ”— è¯¦æƒ…: [æŸ¥çœ‹ GitHub Action æ—¥å¿—](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          # 3. å‘é€é€šçŸ¥
          echo "å‘é€ Webhook é€šçŸ¥..."
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          
          # å°è¯•å‘é€ï¼Œæœ€å¤šé‡è¯•3æ¬¡
          for i in {1..3}; do
              if curl -s -X POST -H "Content-Type: application/json" \
                 -d "$JSON_PAYLOAD" \
                 -w "HTTP Status: %{http_code}" \
                 "${{ secrets.WEBHOOK_URL }}" > /dev/null 2>&1; then
                  echo "âœ… é€šçŸ¥å‘é€æˆåŠŸ (å°è¯• $i æ¬¡)"
                  break
              else
                  echo "âš ï¸ é€šçŸ¥å‘é€å¤±è´¥ï¼Œç¬¬ $i æ¬¡å°è¯•"
                  sleep 2
              fi
          done
